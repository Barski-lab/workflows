import("cmapR", attach=FALSE)
import("dplyr", attach=FALSE)
import("purrr", attach=FALSE)
import("Seurat", attach=FALSE)
import("Signac", attach=FALSE)
import("tibble", attach=FALSE)
import("sceasy", attach=FALSE)
import("SeuratDisk", attach=FALSE)
import("SCopeLoomR", attach=FALSE)
import("rtracklayer", attach=FALSE)
import("scRepertoire", attach=FALSE)
import("GenomeInfoDb", attach=FALSE)
import("GenomicRanges", attach=FALSE)
import("magrittr", `%>%`, attach=TRUE)

export(
    "get_file_type",
    "export_data",
    "export_rds",
    "export_gct",
    "export_cls",
    "load_cell_identity_data",
    "extend_metadata",
    "extend_metadata_by_barcode",
    "apply_metadata_filters",
    "refine_metadata_levels",
    "load_grouping_data",
    "load_blacklist_data",
    "assign_identities",
    "load_10x_multiome_data",
    "load_10x_rna_data",
    "load_10x_vdj_data",
    "load_seqinfo_data",
    "export_h5seurat",
    "export_h5ad",
    "export_scope_loom",
    "export_fragments_coverage",
    "export_coverage",
    "load_cell_cycle_data",
    "replace_fragments"
)


get_file_type <- function (filename){
    ext = tools::file_ext(filename)
    separator = "\t"
    if (ext == "csv"){
        separator = ","
    }
    return (separator)
}

# load_barcodes_data <- function(location, seurat_data){
#     default_barcodes_data <- SeuratObject::Cells(seurat_data)                # to include all available cells
#     if (!is.null(location)){
#         barcodes_data <- utils::read.table(
#             location,
#             sep=get_file_type(location),
#             header=TRUE,
#             check.names=FALSE,
#             stringsAsFactors=FALSE
#         )
#         base::print(
#             base::paste(
#                 "Barcodes data is successfully loaded and from", location,
#                 "and will be used to prefilter feature-barcode matrices by",
#                 "cells of interest")
#         )
#         return (barcodes_data)
#     }
#     base::print("Barcodes data is not provided. Using all cells")
#     return (default_barcodes_data)
# }

load_cell_cycle_data <- function(seurat_data, location){
    base::tryCatch(
        expr = {
            cell_cycle_data <- utils::read.table(
                location,
                sep=get_file_type(location),
                header=TRUE,
                check.names=FALSE,
                stringsAsFactors=FALSE
            )
            if (
                length(
                    base::intersect(
                        base::as.vector(as.character(base::rownames(seurat_data))),         # all genes
                        cell_cycle_data$gene_id                                             # cc genes
                    )
                ) == 0
            ){
                base::print("Loaded cell cycle data has 0 genes present in the dataset")
                return (NULL)
            }
            base::print(
                base::paste(
                    "Cell cycle data is successfully loaded from", location
                )
            )
            return (cell_cycle_data)
        },
        error = function(e){
            base::print(
                base::paste(
                    "Failed to load cell cycle data from", location, "due to", e
                )
            )
            return (NULL)
        }
    )
}

export_fragments_coverage <- function(fragments_data, location){
    base::tryCatch(
        expr = {
            coverage_data <- methods::as(
                base::lapply(
                    GenomicRanges::coverage(fragments_data),
                    function(x) signif(10^6 * x/length(fragments_data), 3)               # scale to RPM mapped
                ),
                "SimpleRleList"
            )
            rtracklayer::export.bw(coverage_data, location)
            base::print(base::paste("Exporting fragments coverage data to", location, sep=" "))
        },
        error = function(e){
            base::print(base::paste("Failed to export fragments coverage data to", location, "due to", e))
        }
    )
}

export_coverage <- function(coverage_data, location){
    base::tryCatch(
        expr = {
            rtracklayer::export.bw(coverage_data, location)
            base::print(base::paste("Exporting coverage data to", location, sep=" "))
        },
        error = function(e){
            base::print(base::paste("Failed to export coverage data to", location, "due to", e))
        }
    )
}

export_data <- function(data, location, row_names=FALSE, col_names=TRUE, quote=FALSE){
    base::tryCatch(
        expr = {
            utils::write.table(
                data,
                file=location,
                sep=get_file_type(location),
                row.names=row_names,
                col.names=col_names,
                quote=quote
            )
            base::print(base::paste("Exporting data to", location, sep=" "))
        },
        error = function(e){
            base::print(base::paste("Failed to export data to", location, "due to", e))
        }
    )
}

export_rds <- function(data, location){
    base::tryCatch(
        expr = {
            base::saveRDS(data, location)
            base::print(base::paste("Exporting data as RDS to", location, sep=" "))
        },
        error = function(e){
            base::print(base::paste("Failed to export data as RDS to", location, sep=" "))
        }
    )
}

export_h5seurat <- function(data, location, overwrite=TRUE){
    base::tryCatch(
        expr = {
            SeuratDisk::SaveH5Seurat(data, location, overwrite=overwrite)
            base::print(base::paste("Exporting data as h5seurat to", location, sep=" "))
        },
        error = function(e){
            base::print(base::paste("Failed to export data as h5seurat to", location, sep=" "))
        }
    )
}

export_h5ad <- function(data, location){
    base::tryCatch(
        expr = {
            sceasy::convertFormat(data, from="seurat", to="anndata", outFile=location)
            base::print(base::paste("Exporting data as h5ad to", location, sep=" "))
        },
        error = function(e){
            base::print(base::paste("Failed to export data as h5ad to", location, sep=" "))
        }
    )
}

export_scope_loom <- function(data, location, assay="RNA", slot="counts"){
    base::tryCatch(
        expr = {
            SeuratObject::DefaultAssay(data) <- assay
            SCopeLoomR::build_loom(
                file.name=location,
                dgem=SeuratObject::GetAssayData(object=data, slot=slot)
            )
            loom_handler <- SCopeLoomR::open_loom(location, mode="r+")              # open Loom file for adding data

            for (i in 1:length(data@reductions)){                                   # at least one reduction will be present, because
                reduction_name <- names(data@reductions)[i]                         # because we are not supposed to call this function
                SCopeLoomR::add_embedding(                                          # when there is nothing to show
                    loom=loom_handler,
                    embedding=base::as.data.frame(                                  # need as.data.frame, otherwise all.equal fails (in SCopeLoomR)
                        SeuratObject::Embeddings(data, reduction=reduction_name)
                    ),
                    name=reduction_name,
                    is.default=(i == 1)                                             # first found reduction will be default
                )
            }

            meta_fields <- base::append(
                c("new.ident", "condition"),                                        # these two fields should be always present in out Seurat object
                base::grep(                                                         # will be [] if no custom fields are present
                    "^custom_",
                    base::colnames(data@meta.data),
                    value=TRUE,
                    ignore.case=TRUE
                )
            )
            for (i in 1:length(meta_fields)){
                SCopeLoomR::add_col_attr(
                    loom=loom_handler,
                    key=meta_fields[i],
                    value=base::as.vector(
                        as.character(data@meta.data[ , meta_fields[i] ])
                    ),
                    as.annotation=TRUE                                              # adding as categorical value
                )
            }

            cluster_fields <- base::grep(
                "^rna_res\\.|^atac_res\\.|^wsnn_res\\.",                            # we need only columns with numeric cluster values
                base::colnames(data@meta.data),
                value=TRUE,
                ignore.case=TRUE
            )
            for (i in 1:length(cluster_fields)){
                cluster_data <- base::as.vector(as.character(data@meta.data[ , cluster_fields[i] ]))
                names(cluster_data) <- rownames(data@meta.data)
                SCopeLoomR::add_annotated_clustering(
                    loom=loom_handler,
                    group="Clustering",
                    name=cluster_fields[i],
                    clusters=cluster_data,
                    annotation=cluster_data
                )
            }

            SCopeLoomR::close_loom(loom_handler)

            base::print(base::paste("Exporting SCope compatible loom file to", location, sep=" "))
        },
        error = function(e){
            base::print(
                base::paste(
                    "Failed to export SCope compatible loom file to", location, "due to", e
                )
            )
        }
    )
}

load_cell_identity_data <- function(location) {
    cell_identity_data <- utils::read.table(
        location,
        sep=get_file_type(location),
        header=TRUE,
        check.names=FALSE,
        stringsAsFactors=FALSE
    )
    if ("sample_id" %in% base::colnames(cell_identity_data)){             # the latest cellranger changed the name from library_id to sample_id
        cell_identity_data <- cell_identity_data %>%
                              dplyr::rename("library_id"="sample_id")     # we use "library_id" in our code
    }
    # prepend with LETTERS, otherwise the order on the plot will be arbitrary sorted
    cell_identity_data <- cell_identity_data %>%
                          dplyr::mutate("library_id"=base::paste(LETTERS[1:base::nrow(cell_identity_data)], .$library_id))
    return (cell_identity_data)
}

extend_metadata <- function(seurat_data, location, seurat_ref_column, meta_ref_column, seurat_target_columns=NULL){
    metadata <- utils::read.table(
        location,
        sep=get_file_type(location),
        header=TRUE,
        check.names=FALSE,
        stringsAsFactors=FALSE
    )
    base::print(base::paste("Metadata is successfully loaded from", location))
    base::print(metadata)
    seurat_ref_values <- base::as.vector(as.character(seurat_data@meta.data[, seurat_ref_column]))
    meta_ref_values <- base::as.vector(as.character(metadata[, meta_ref_column]))
    if (!all(base::sort(meta_ref_values) == base::sort(base::unique(seurat_ref_values)))){
        base::print("Extra metadata file is malformed. Exiting.")
        base::quit(save="no", status=1, runLast=FALSE)
    }
    meta_source_columns <- base::colnames(metadata)[base::colnames(metadata) != meta_ref_column]        # all except ref column from metadata
    if (is.null(seurat_target_columns)){
        seurat_target_columns <- meta_source_columns                                                    # using the names from the metadata file
    } else if (length(seurat_target_columns) != length(meta_source_columns)){
        base::print("Provided target column names cannot be used with the loaded metadata. Exiting.")
        base::quit(save="no", status=1, runLast=FALSE)
    }
    for (i in 1:length(meta_source_columns)){
        current_meta_source_column <- meta_source_columns[i]
        current_seurat_target_column <- seurat_target_columns[i]
        base::print(base::paste("Adding", current_meta_source_column, "as", current_seurat_target_column, "column"))
        seurat_data[[current_seurat_target_column]] <- base::as.factor(                                  # need as.factor, otherwise the order on the plots might be mismatched
            metadata[[current_meta_source_column]][base::match(seurat_ref_values, meta_ref_values)]
        )
    }
    base::rm(metadata, seurat_ref_values, meta_ref_values)
    return (seurat_data)
}

refine_metadata_levels <- function(seurat_data){
    for (i in base::colnames(seurat_data@meta.data)){
        if (base::is.factor(seurat_data@meta.data[[i]])){
            base::print(base::paste("Re-evaluating levels for a factor column", i))
            base::print(
                base::paste(
                    "before:", base::paste(base::levels(seurat_data@meta.data[[i]]), collapse=", ")
                )
            )
            seurat_data@meta.data[[i]] <- base::droplevels(seurat_data@meta.data[[i]])  # need to drop levels of the removed values
            base::print(
                base::paste(
                    "after:", base::paste(base::levels(seurat_data@meta.data[[i]]), collapse=", ")
                )
            )
        }
    }
    return (seurat_data)
}

apply_metadata_filters <- function(seurat_data, target_column, target_values){
    base::print(
        base::paste(
            "Include only", base::paste(target_values, collapse=", "),
            "values from the", target_column, "metadata column."
        )
    )
    base::print(base::paste("Cells before filtering", base::nrow(seurat_data@meta.data)))
    SeuratObject::Idents(seurat_data) <- target_column
    seurat_data <- base::subset(seurat_data, idents=target_values)
    seurat_data <- refine_metadata_levels(seurat_data)                                    # to drop empty levels
    SeuratObject::Idents(seurat_data) <- "new.ident"
    base::print(base::paste("Cells after filtering", base::nrow(seurat_data@meta.data)))
    return (seurat_data)
}

extend_metadata_by_barcode <- function(seurat_data, location, filter=FALSE){
    metadata <- utils::read.table(
        location,
        sep=get_file_type(location),
        header=TRUE,
        check.names=FALSE,
        stringsAsFactors=FALSE
    ) %>% dplyr::rename("barcode"=1)                                                      # rename the first column to barcode

    base::print(base::paste("Barcodes metadata is successfully loaded from ", location))

    if (filter){
        base::print(base::paste("Filtering Seurat data by loaded barcodes"))
        base::print(base::paste("Cells before filtering", base::nrow(seurat_data@meta.data)))
        seurat_data <- base::subset(seurat_data, cells=metadata$barcode)                  # subset to only selected cells
        seurat_data <- refine_metadata_levels(seurat_data)                                # to drop empty levels
        base::print(base::paste("Cells after filtering", base::nrow(seurat_data@meta.data)))
    }
    if (base::ncol(metadata) > 1){
        base::print(
            base::paste(
                "Extending Seurat object metadata with",
                base::paste(base::colnames(metadata)[2:length(base::colnames(metadata))], collapse=", "),
                "column(s)"
            )
        )
        refactored_metadata <- base::data.frame(SeuratObject::Cells(seurat_data)) %>%     # create a dataframe with only one column
                               dplyr::rename("barcode"=1) %>%                             # rename that column to barcode
                               dplyr::left_join(metadata, by="barcode") %>%               # intersect with loaded extra metadata by "barcode"
                               tibble::remove_rownames() %>%
                               tibble::column_to_rownames("barcode") %>%
                               replace(is.na(.), "Unknown")                               # in case Seurat object had more barcodes than loaded extra metadata
        seurat_data <- SeuratObject::AddMetaData(
            seurat_data,
            refactored_metadata[SeuratObject::Cells(seurat_data), , drop=FALSE]           # to guarantee the proper cells order
        )
    }
    SeuratObject::Idents(seurat_data) <- "new.ident"                                      # in case we updated new.ident columns with the new values
    return (seurat_data)
}

load_grouping_data <- function(location, cell_identity_data) {
    default_grouping_data <- base::data.frame(
        library_id=cell_identity_data$library_id,
        condition=cell_identity_data$library_id,
        check.names=FALSE,
        stringsAsFactors=FALSE
    )
    if (!is.null(location)){
        grouping_data <- utils::read.table(
            location,
            sep=get_file_type(location),
            header=TRUE,
            check.names=FALSE,
            stringsAsFactors=FALSE
        )
        # prepend with LETTERS to correspond to the library_id from the cell_identity_data
        grouping_data <- grouping_data %>%
                          dplyr::mutate("library_id"=base::paste(LETTERS[1:base::nrow(grouping_data)], .$library_id))
        if ( (base::nrow(grouping_data) == base::nrow(cell_identity_data)) && all(base::is.element(cell_identity_data$library_id, grouping_data$library_id)) ){
            base::print(base::paste("Grouping data is successfully loaded from ", location))
            return (grouping_data)
        } else {
            base::print(base::paste("Applying defaults - grouping data loaded from", location, "is malformed"))
            return (default_grouping_data)
        }
    }
    base::print("Grouping data is not provided. Applying defaults")
    return (default_grouping_data)
}

load_blacklist_data <- function(location) {
    default_blacklist_data <- NULL
    if (!is.null(location)){
        blacklist_data <- rtracklayer::import(location, format="BED")
        base::print(base::paste("Genomic blacklist regions data is successfully loaded from ", location))
        return (blacklist_data)
    }
    base::print("File with the genomic blacklist regions is not provided. Cells won't be filtered by --maxblacklist")
    return (default_blacklist_data)
}

load_seqinfo_data <- function(location) {
    raw_data <- utils::read.table(
        location,
        sep=get_file_type(location),
        header=FALSE,
        check.names=FALSE,
        stringsAsFactors=FALSE
    )
    seqinfo_data <- GenomeInfoDb::Seqinfo(
        seqnames=raw_data[[1]],
        seqlengths=raw_data[[2]],
        isCircular=rep(FALSE, length(raw_data[[1]]))                                      # to be able to use trim on GenomicRanges object
    )
    base::print(base::paste("Chromosome length data is successfully loaded from ", location))
    return (seqinfo_data)
}

assign_identities <- function(seurat_data, cell_identity_data, grouping_data){
    SeuratObject::Idents(seurat_data) <- "orig.ident"                                     # safety measure to make sure we get correct Idents
    idents <- as.numeric(as.character(SeuratObject::Idents(seurat_data)))                 # need to properly convert factor to numeric vector
    new_ident <- cell_identity_data$library_id[idents]
    if (sum(is.na(new_ident)) > 0){
        base::print("Identity file includes less than expected number of rows. Exiting.")
        base::quit(save="no", status=1, runLast=FALSE)
    }
    seurat_data[["new.ident"]] <- new_ident
    seurat_data[["condition"]] <- grouping_data$condition[base::match(seurat_data$new.ident, grouping_data$library_id)]
    SeuratObject::Idents(seurat_data) <- "new.ident"
    if (base::nrow(cell_identity_data) > length(base::unique(base::as.vector(as.character(SeuratObject::Idents(seurat_data)))))){
        base::print("Identity file includes more than expected number of rows. Exiting.")
        base::quit(save="no", status=1, runLast=FALSE)
    }
    base::rm(idents, new_ident)
    return (seurat_data)
}

load_10x_multiome_data <- function(args, cell_identity_data, grouping_data, seqinfo_data) {
    base::suppressMessages(raw_data <- Seurat::Read10X(data.dir=args$mex))
    seurat_data <- SeuratObject::CreateSeuratObject(
        counts=raw_data$`Gene Expression`,
        min.cells=args$rnamincells,
        names.delim="-",
        names.field=2
    )
    annotation <- rtracklayer::import(args$annotations, format="GFF")

    if( !("gene_biotype" %in% base::colnames(GenomicRanges::mcols(annotation))) ){
        base::print(
            paste(
                "Loaded genome annotation doesn't have 'gene_biotype' column.",
                "Setting to NA"
            )
        )
        annotation$gene_biotype <- NA                                                               # some Signac functions fail without this column
    }
    if( !("tx_id" %in% base::colnames(GenomicRanges::mcols(annotation))) ){
        base::print(
            base::paste(
                "Loaded genome annotation doesn't have 'tx_id' column.",
                "Setting it from 'transcript_id'"
            )
        )
        annotation$tx_id <- annotation$transcript_id                                                # https://github.com/stuart-lab/signac/issues/1159
    }

    all_cells <- SeuratObject::Cells(seurat_data)
    names(all_cells) <- all_cells
    base::print(
        base::paste(
            "Preparing fragments for", length(all_cells), "cells"
        )
    )
    fragments <- Signac::CreateFragmentObject(
        path=args$fragments,
        cells=all_cells,
        validate.fragments=TRUE,
        verbose=FALSE
    )
    peak_coordinates <- Signac::StringToGRanges(
        regions=base::rownames(raw_data$Peaks),
        sep=c(":", "-")                            # need to run it explicitely with correct sep, as in FeatureMatrix 1) they have bug, 2) for consistency we'll use ("-", "-")
    )
    base::print(
        base::paste(
            "Counting fragments overlapping", length(peak_coordinates), "peaks"
        )
    )
    peak_counts <- Signac::FeatureMatrix(                                                 # need to recalculate feature-barcode matrix to include fragments, not reads
        fragments=fragments,
        sep=c("-", "-"),                                                                  # unexplainable bug - fails if use sep=c(":", "-")
        features=peak_coordinates,
        cells=all_cells,
        verbose=FALSE
    )
    seurat_data[["ATAC"]] <- Signac::CreateChromatinAssay(
        counts=peak_counts,
        sep=c("-", "-"),
        fragments=fragments,
        min.cells=args$atacmincells,
        annotation=annotation,
        genome=seqinfo_data                                                               # we will need it when we want to export genome coverage to bigWig files
    )
    base::print("Assigning new dataset identities")
    seurat_data <- assign_identities(seurat_data, cell_identity_data, grouping_data)
    base::rm(raw_data, annotation, all_cells, fragments, peak_coordinates, peak_counts)   # removing unused data
    base::gc(verbose=FALSE)
    return (seurat_data)
}

load_10x_rna_data <- function(args, cell_identity_data, grouping_data) {
    if (length(args$mex) == 1){
        base::print("Single feature-barcode matrix is provided. Using the original barcode suffixes")
        seurat_data <- SeuratObject::CreateSeuratObject(
            counts=Seurat::Read10X(data.dir=args$mex),
            min.cells=args$rnamincells,
            names.delim="-",
            names.field=2
        )
        base::print("Assigning new dataset identities")
        seurat_data <- assign_identities(seurat_data, cell_identity_data, grouping_data)
        return (seurat_data)
    } else {
        base::print("Multiple feature-barcode matrices are provided. Original barcode suffixes will be updated")
        merged_seurat_data <- NULL
        for (i in 1:length(args$mex)){
            current_location <- args$mex[i]
            base::print(
                base::paste(
                    "Reading 10x data from", current_location,
                    "replacing the original barcode suffixes with", i
                )
            )
            seurat_data <- SeuratObject::CreateSeuratObject(
                counts=Seurat::Read10X(
                    data.dir=current_location,
                    strip.suffix=TRUE             # removes suffix from barcode
                )
            )
            idents <- i
            new_ident <- cell_identity_data$library_id[idents]
            base::print(base::paste("Assigning new identity", new_ident))
            if (sum(is.na(new_ident)) > 0){
                base::print("Identity file includes less than expected number of rows. Exiting.")
                base::quit(save="no", status=1, runLast=FALSE)
            }
            seurat_data[["new.ident"]] <- new_ident
            seurat_data[["condition"]] <- grouping_data$condition[base::match(seurat_data$new.ident, grouping_data$library_id)]
            SeuratObject::Idents(seurat_data) <- "new.ident"
            seurat_data <- SeuratObject::RenameCells(
                seurat_data,
                new.names=base::paste0(SeuratObject::Cells(seurat_data), "-", idents)      # to add new barcode suffix
            )
            if (is.null(merged_seurat_data)){
                merged_seurat_data <- seurat_data
            } else {
                merged_seurat_data <- base::merge(merged_seurat_data, y=seurat_data)
            }
            base::rm(seurat_data, idents, new_ident)                                       # remove unused data
        }
        if (base::nrow(cell_identity_data) > length(base::unique(base::as.vector(as.character(SeuratObject::Idents(merged_seurat_data)))))){
            base::print("Identity file includes more than expected number of rows. Exiting.")
            base::quit(save="no", status=1, runLast=FALSE)
        }
        base::gc(verbose=FALSE)
        return (merged_seurat_data)
    }
}

load_10x_vdj_data <- function(seurat_data, args) {
    base::print(
        base::paste(
            "Loading congtigs annotations from", args$contigs
        )
    )
    congtigs_data <- scRepertoire::createHTOContigList(            # should work even if seurat_data includes only one dataset
        contig=utils::read.table(
            args$contigs,
            sep=get_file_type(args$contigs),
            header=TRUE,
            check.names=FALSE,
            stringsAsFactors=FALSE
        ),
        sc=seurat_data,                                                # the order of barcode suffixes should be the same as in contigs
        group.by="new.ident"
    )

    base::print("Raw contigs counts")
    for(i in seq_along(congtigs_data)) {
        base::print(nrow(congtigs_data[[i]]))
    }

    filter_by_cells=!is.null(args$filter) && args$filter == "cells"
    filter_by_chains=!is.null(args$filter) && args$filter == "chains"
    if (filter_by_cells || filter_by_chains){
        base::print(
            base::paste(
                "Applying filtering",
                ifelse(filter_by_cells, "by cells", "by chains")
            )
        )
    }

    detected_chains <- base::sort(base::unique(congtigs_data[[1]]$chain))      # assuming that taking the first item from the list is ok
    if (base::identical(c("TRA", "TRB"), detected_chains)) {
        base::print("Combining T Cell receptor contigs")
        congtigs_data <- scRepertoire::combineTCR(
            df=congtigs_data,
            removeNA=FALSE,                                            # should be FALSE, because of https://github.com/ncborcherding/scRepertoire/issues/293
            removeMulti=filter_by_cells,
            filterMulti=filter_by_chains
        )
    } else if (base::identical(c("IGH", "IGL"), detected_chains)){
        base::print("Combining B Cell receptor contigs")
        congtigs_data <- scRepertoire::combineBCR(
            df=congtigs_data,
            removeNA=FALSE,                                            # not tested for BCR, but better to follow the same logic as for combineTCR
            removeMulti=filter_by_cells,
            filterMulti=filter_by_chains
        )
    } else {
        base::print("Not implemented chains detected. Exiting")
        quit(save="no", status=1, runLast=FALSE)
    }

    if (args$removepartial){
        base::print("Removing cells with only one chain detected")
        for(i in seq_along(congtigs_data)) {
            congtigs_data[[i]] <- congtigs_data[[i]] %>%
                tidyr::drop_na(
                    tidyselect::any_of(
                        c("TCR1", "TCR2", "IGH", "IGLC")               # doesn't fail because of the missing columns, so it can be used for both TCR and BCR
                    )
                )
        }
    }

    base::print(                                                       # otherwise combineExpression calculates Frequencies within each sample independently
        base::paste(
            "Combining all contigs into a single list",
            "after all filters applied"
        )
    )
    congtigs_data <- dplyr::bind_rows(congtigs_data)

    seurat_data <- scRepertoire::combineExpression(
        df=congtigs_data,
        sc=seurat_data,
        cloneCall=args$cloneby,
        proportion=FALSE,                                     # to get clonotypes counts instead of frequency
        cloneTypes=c(                                         # None (0, 1)
            single=1,                                         # single (0, 1]
            multiple=Inf                                      # multiple (1, Inf)
        ),
        group.by="none"                                       # to calculate clonotypes Frequencies for all samples jointly
    )
    seurat_data@misc$vdj <- list(
        chains=detected_chains                                # will always be either c("TRA", "TRB") or c("IGH", "IGL")
    )
    clonotype_column <- switch(
        args$cloneby,
        "gene"   = "CTgene",
        "nt"     = "CTnt",
        "aa"     = "CTaa",
        "strict" = "CTstrict"
    )
    seurat_data@meta.data <- seurat_data@meta.data %>%
        dplyr::rename("clntp_counts"="Frequency") %>%
        tidyr::replace_na(list(clntp_counts=0)) %>%           # to replace all NA with 0 counts
        dplyr::mutate("clntp"=.[[clonotype_column]]) %>%
        dplyr::select(-c("barcode"))                          # need to keep "CTgene", "CTnt", "CTaa", "CTstrict", and "cloneType" columns for plots


        # dplyr::mutate(CTgene=ifelse(Frequency <= 0.01, "NA", CTgene)) %>%
        # dplyr::mutate(CTnt=ifelse(Frequency <= 0.01, "NA", CTnt)) %>%
        # dplyr::mutate(CTaa=ifelse(Frequency <= 0.01, "NA", CTaa)) %>%
        # dplyr::mutate(CTstrict=ifelse(Frequency <= 0.01, "NA", CTstrict))

    base::rm(congtigs_data)
    base::gc(verbose=FALSE)

    return (seurat_data)
}

replace_fragments <- function(location, seurat_data){
    SeuratObject::DefaultAssay(seurat_data) <- "ATAC"                                # safety measure
    Signac::Fragments(seurat_data[["ATAC"]]) <- NULL                                 # remove old fragments
    all_cells <- SeuratObject::Cells(seurat_data)
    names(all_cells) <- all_cells
    base::print(base::paste("Preparing fragments for", length(all_cells), "cells"))
    fragments <- Signac::CreateFragmentObject(
        path=location,
        cells=all_cells,
        validate.fragments=TRUE,
        verbose=FALSE
    )
    Signac::Fragments(seurat_data[["ATAC"]]) <- fragments
    return(seurat_data)
}

export_gct <- function(counts_mat, location, row_metadata=NULL, col_metadata=NULL){
    base::tryCatch(
        expr = {
            if (!is.null(row_metadata)){
                row_metadata <- row_metadata %>%
                                tibble::rownames_to_column("id") %>%
                                dplyr::mutate_at("id", base::as.vector)
                counts_mat <- counts_mat[row_metadata$id, ]                      # to guarantee the order and number of rows
            }
            if (!is.null(col_metadata)){
                col_metadata <- col_metadata %>%
                                tibble::rownames_to_column("id") %>%
                                dplyr::mutate_at("id", base::as.vector)
                counts_mat <- counts_mat[, col_metadata$id]                      # to guarantee the order and number of columns
            }
            gct_data <- methods::new(
                "GCT",
                mat=counts_mat,
                rdesc=row_metadata,                                              # can be NULL
                cdesc=col_metadata                                               # can be NULL
            )
            cmapR::write_gct(
                ds=gct_data,
                ofile=location,
                appenddim=FALSE
            )
            base::print(base::paste("Exporting GCT data to", location, sep=" "))
        },
        error = function(e){
            base::print(base::paste("Failed to export GCT data to ", location, "with error - ", e, sep=""))
        }
    )
}

export_cls <- function(categories, location){
    base::tryCatch(
        expr = {
            output_stream <- base::file(location, "w")
            on.exit(base::close(output_stream), add=TRUE)           # can't put it in 'finally' as there is no access to output_stream variable
            base::cat(
                base::paste(
                    length(categories),                             # number of datasets
                    length(base::levels(categories)),               # number of different categories
                    "1",                                            # should be always 1
                    sep="\t"
                ),
                base::paste(
                    "#",
                    base::paste(
                        base::unique(as.character(categories)),     # preserves the order, but removes duplicates
                        collapse="\t"
                    ),
                    sep="\t"
                ),
                base::paste(
                    base::paste(
                        as.character(categories),
                        collapse="\t"
                    ),
                    sep="\t"
                ),
                file=output_stream,
                sep="\n"
            )
            base::print(base::paste("Exporting CLS data to", location, sep=" "))
        },
        error = function(e){
            base::print(base::paste("Failed to export CLS data to ", location, "with error - ", e, sep=""))
        }
    )
}