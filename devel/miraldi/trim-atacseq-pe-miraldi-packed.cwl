cwlVersion: v1.0
class: Workflow


requirements:
  - class: SubworkflowFeatureRequirement
  - class: ScatterFeatureRequirement
  - class: StepInputExpressionRequirement
  - class: MultipleInputFeatureRequirement
  - class: InlineJavascriptRequirement
    expressionLib:
    - var get_root = function(basename) {
          return basename.split('.').slice(0,1).join('.');
      };


inputs:

  fastq_file_1:
    type: File
    doc: "Paired-end sequencing data 1 in FASTQ format (fastq, fq, bzip2, gzip, zip)"

  fastq_file_2:
    type: File
    doc: "Paired-end sequencing data 2 in FASTQ format (fastq, fq, bzip2, gzip, zip)"

  indices_folder:
    type: Directory
    doc: "Directory with the genome indices generated by Bowtie2"

  exclude_chromosome:
    type: string?
    default: "chrM chrY chrX"
    doc: "Case-sensitive space-separated chromosome list to be excluded"

  blacklisted_regions_bed:
    type: File
    doc: "Blacklisted genomic regions file in BED format"

  chrom_length_file:
    type: File
    doc: "Chromosome length file"

  genome_size:
    type: string
    doc: "The length of the mappable genome (hs, mm, ce, dm or number, for example 2.7e9)"

  genome_fasta_file:
    type: File
    secondaryFiles: $(self.basename+".fai")  # due to bug in cwltool==1.0.20190621234233
    doc: "Reference genome sequence FASTA and FAI index files"

  threads:
    type: int?
    default: 4
    doc: "Number of threads for those steps that support multithreading"


outputs:

  fastq_1_qc_report_original:
    type: File
    outputSource: rename_qc_fastq_1_report/target_file

  fastq_1_adapter_trimming_report:
    type: File
    outputSource: trim_adapters/report_file

  fastq_2_qc_report_original:
    type: File
    outputSource: rename_qc_fastq_2_report/target_file

  fastq_2_adapter_trimming_report:
    type: File
    outputSource: trim_adapters/report_file_pair
  
  alignment_log:
    type: File
    outputSource: align_reads/output_log

  aligned_reads:
    type: File
    outputSource: sort_and_index/bam_bai_pair

  alignment_statistics:
    type: File
    outputSource: get_alignment_statistics/log_file

  read_redundancy_estimation:
    type: File
    outputSource: estimate_read_redundancy/estimates_file

  genome_coverage:
    type: File
    outputSource: convert_genome_coverage_to_bigwig/bigwig_file

  peak_calling_log:
    type: File
    outputSource: call_peaks/macs_log

  merged_peaks_with_counts:
    type: File
    outputSource: count_tags/intersected_file

  merged_peaks_sequences:
    type: File
    outputSource: get_sequences/sequences_file


steps:


# -----------------------------------------------------------------------------------


  extract_fastq_1:
    run:
      cwlVersion: v1.0
      class: CommandLineTool
      requirements:
      - class: ShellCommandRequirement
      hints:
      - class: DockerRequirement
        dockerPull: biowardrobe2/scidap:v0.0.3
      inputs:
        script:
          type: string?
          default: |
            #!/bin/bash
            shopt -s nocaseglob
            FILE=$0
            DEFAULT_EXT=$1
            EXT_LIST=( ".fastq" ".fq" )
            BASENAME=$(basename "$FILE")
            ROOT_NAME="${BASENAME%.*}"
            for ITEM in $EXT_LIST; do
              if [[ $ROOT_NAME == *$ITEM ]]; then
                DEFAULT_EXT=""
              fi
            done
            T=`file -b "${FILE}" | awk '{print $1}'`
            case "${T}" in
              "bzip2"|"gzip"|"Zip")
                7z e -so "${FILE}" > "${ROOT_NAME}${DEFAULT_EXT}"
                ;;
              "ASCII")
                cp "${FILE}" "${ROOT_NAME}${DEFAULT_EXT}" || true
                ;;
              *)
                echo "Error: file type unknown"
                exit 1
            esac
          inputBinding:
            position: 5
          doc: |
            Bash script to extract compressed FASTQ file
        compressed_file:
          type: File
          inputBinding:
            position: 6
          doc: |
            Compressed or uncompressed FASTQ file
        output_file_ext:
          type: string?
          inputBinding:
            position: 7
          default: ".fastq"
          doc: |
            Default extension for the extracted file
      outputs:
        fastq_file:
          type: File
          outputBinding:
            glob: "*"
      baseCommand: [bash, '-c']
    in:
      compressed_file: fastq_file_1
    out: [fastq_file]

  qc_fastq_1:
    run:
      cwlVersion: v1.0
      class: CommandLineTool
      requirements:
      - class: InlineJavascriptRequirement
      hints:
      - class: DockerRequirement
        dockerPull: biowardrobe2/fastqc:v0.11.5
      inputs:
        reads_file:
          type:
            - File
          inputBinding:
            position: 50
          doc: |
            Input bam,sam,bam_mapped,sam_mapped or fastq file
        format_enum:
          type:
            - "null"
            - type: enum
              name: "format"
              symbols: ['bam','sam','bam_mapped','sam_mapped','fastq']
          inputBinding:
            position: 6
            prefix: '--format'
          doc: |
            Bypasses the normal sequence file format detection and
            forces the program to use the specified format.  Valid
            formats are bam,sam,bam_mapped,sam_mapped and fastq
        threads:
          type:
            - "null"
            - int
          inputBinding:
            position: 7
            prefix: '--threads'
          doc: |
            Specifies the number of files which can be processed
            simultaneously.  Each thread will be allocated 250MB of
            memory so you shouldn't run more threads than your
            available memory will cope with, and not more than
            6 threads on a 32 bit machine
        contaminants:
          type:
            - "null"
            - File
          inputBinding:
            position: 8
            prefix: '--contaminants'
          doc: |
            Specifies a non-default file which contains the list of
            contaminants to screen overrepresented sequences against.
            The file must contain sets of named contaminants in the
            form name[tab]sequence.  Lines prefixed with a hash will
            be ignored.
        adapters:
          type:
            - "null"
            - File
          inputBinding:
            position: 9
            prefix: '--adapters'
          doc: |
            Specifies a non-default file which contains the list of
            adapter sequences which will be explicity searched against
            the library. The file must contain sets of named adapters
            in the form name[tab]sequence.  Lines prefixed with a hash
            will be ignored.
        limits:
          type:
            - "null"
            - File
          inputBinding:
            position: 10
            prefix: '--limits'
          doc: |
            Specifies a non-default file which contains a set of criteria
            which will be used to determine the warn/error limits for the
            various modules.  This file can also be used to selectively
            remove some modules from the output all together.  The format
            needs to mirror the default limits.txt file found in the
            Configuration folder.
        kmers:
          type:
            - "null"
            - int
          inputBinding:
            position: 11
            prefix: '--kmers'
          doc: |
            Specifies the length of Kmer to look for in the Kmer content
            module. Specified Kmer length must be between 2 and 10. Default
            length is 7 if not specified.
        casava:
          type:
            - "null"
            - boolean
          inputBinding:
            position: 13
            prefix: '--casava'
          doc: |
            Files come from raw casava output. Files in the same sample
            group (differing only by the group number) will be analysed
            as a set rather than individually. Sequences with the filter
            flag set in the header will be excluded from the analysis.
            Files must have the same names given to them by casava
            (including being gzipped and ending with .gz) otherwise they
            won't be grouped together correctly.
        nofilter:
          type:
            - "null"
            - boolean
          inputBinding:
            position: 14
            prefix: '--nofilter'
          doc: |
            If running with --casava then don't remove read flagged by
            casava as poor quality when performing the QC analysis.
        hide_group:
          type:
            - "null"
            - boolean
          inputBinding:
            position: 15
            prefix: '--nogroup'
          doc: |
            Disable grouping of bases for reads >50bp. All reports will
            show data for every base in the read.  WARNING: Using this
            option will cause fastqc to crash and burn if you use it on
            really long reads, and your plots may end up a ridiculous size.
            You have been warned!
      outputs:
        zipped_file:
          type:
            - File
          outputBinding:
            glob: '*.zip'
        html_file:
          type:
            - File
          outputBinding:
            glob: '*.html'
        summary_file:
          type:
            - File
          outputBinding:
            glob: |
              ${
                return "*/summary.txt";
              }
      baseCommand: [fastqc, --extract, --outdir, .]
    in:
      reads_file: extract_fastq_1/fastq_file
    out:
      - summary_file
      - html_file

  rename_qc_fastq_1_report:
    run:
      cwlVersion: v1.0
      class: CommandLineTool
      requirements:
      - class: InlineJavascriptRequirement
        expressionLib:
        - var get_target_name = function() {
              return inputs.target_filename.split('/').slice(-1)[0];
          }
      hints:
      - class: DockerRequirement
        dockerPull: biowardrobe2/scidap:v0.0.2
      inputs:
        source_file:
          type: File
          inputBinding:
            position: 5
        target_filename:
          type: string
          inputBinding:
            position: 6
            valueFrom: $(get_target_name())
      outputs:
        target_file:
          type: File
          outputBinding:
            glob: $(get_target_name())
      baseCommand: ["cp"]
    in:
      source_file: qc_fastq_1/html_file
      target_filename:
        source: fastq_file_1
        valueFrom: $(get_root(self.basename)+"_qc_original.html")
    out: [target_file]

  trigger_fastq_1_adapter_trimming:
    run:
      cwlVersion: v1.0
      class: ExpressionTool
      requirements:
        - class: InlineJavascriptRequirement
      id: "fastqc_results_trigger"
      inputs:
        summary_file:
          type: File
          inputBinding:
            loadContents: true
      outputs:
        trigger: boolean
      expression: |
        ${
          var criteria_array = inputs.summary_file.contents.match(/.*Per base sequence quality.*|.*Per sequence quality scores.*|.*Overrepresented sequences.*|.*Adapter Content.*/g);
          if (criteria_array.length > 0){
            if (criteria_array.toString().match(/FAIL/g) != null){
              return { "trigger": true };
            } else {
              return { "trigger": false };
            }
          } else {
            return { "trigger": true };
          }
        }
    in:
      summary_file: qc_fastq_1/summary_file
    out: [trigger]


# -----------------------------------------------------------------------------------


  extract_fastq_2:
    run:
      cwlVersion: v1.0
      class: CommandLineTool
      requirements:
      - class: ShellCommandRequirement
      hints:
      - class: DockerRequirement
        dockerPull: biowardrobe2/scidap:v0.0.3
      inputs:
        script:
          type: string?
          default: |
            #!/bin/bash
            shopt -s nocaseglob
            FILE=$0
            DEFAULT_EXT=$1
            EXT_LIST=( ".fastq" ".fq" )
            BASENAME=$(basename "$FILE")
            ROOT_NAME="${BASENAME%.*}"
            for ITEM in $EXT_LIST; do
              if [[ $ROOT_NAME == *$ITEM ]]; then
                DEFAULT_EXT=""
              fi
            done
            T=`file -b "${FILE}" | awk '{print $1}'`
            case "${T}" in
              "bzip2"|"gzip"|"Zip")
                7z e -so "${FILE}" > "${ROOT_NAME}${DEFAULT_EXT}"
                ;;
              "ASCII")
                cp "${FILE}" "${ROOT_NAME}${DEFAULT_EXT}" || true
                ;;
              *)
                echo "Error: file type unknown"
                exit 1
            esac
          inputBinding:
            position: 5
          doc: |
            Bash script to extract compressed FASTQ file
        compressed_file:
          type: File
          inputBinding:
            position: 6
          doc: |
            Compressed or uncompressed FASTQ file
        output_file_ext:
          type: string?
          inputBinding:
            position: 7
          default: ".fastq"
          doc: |
            Default extension for the extracted file
      outputs:
        fastq_file:
          type: File
          outputBinding:
            glob: "*"
      baseCommand: [bash, '-c']
    in:
      compressed_file: fastq_file_2
    out: [fastq_file]

  qc_fastq_2:
    run:
      cwlVersion: v1.0
      class: CommandLineTool
      requirements:
      - class: InlineJavascriptRequirement
      hints:
      - class: DockerRequirement
        dockerPull: biowardrobe2/fastqc:v0.11.5
      inputs:
        reads_file:
          type:
            - File
          inputBinding:
            position: 50
          doc: |
            Input bam,sam,bam_mapped,sam_mapped or fastq file
        format_enum:
          type:
            - "null"
            - type: enum
              name: "format"
              symbols: ['bam','sam','bam_mapped','sam_mapped','fastq']
          inputBinding:
            position: 6
            prefix: '--format'
          doc: |
            Bypasses the normal sequence file format detection and
            forces the program to use the specified format.  Valid
            formats are bam,sam,bam_mapped,sam_mapped and fastq
        threads:
          type:
            - "null"
            - int
          inputBinding:
            position: 7
            prefix: '--threads'
          doc: |
            Specifies the number of files which can be processed
            simultaneously.  Each thread will be allocated 250MB of
            memory so you shouldn't run more threads than your
            available memory will cope with, and not more than
            6 threads on a 32 bit machine
        contaminants:
          type:
            - "null"
            - File
          inputBinding:
            position: 8
            prefix: '--contaminants'
          doc: |
            Specifies a non-default file which contains the list of
            contaminants to screen overrepresented sequences against.
            The file must contain sets of named contaminants in the
            form name[tab]sequence.  Lines prefixed with a hash will
            be ignored.
        adapters:
          type:
            - "null"
            - File
          inputBinding:
            position: 9
            prefix: '--adapters'
          doc: |
            Specifies a non-default file which contains the list of
            adapter sequences which will be explicity searched against
            the library. The file must contain sets of named adapters
            in the form name[tab]sequence.  Lines prefixed with a hash
            will be ignored.
        limits:
          type:
            - "null"
            - File
          inputBinding:
            position: 10
            prefix: '--limits'
          doc: |
            Specifies a non-default file which contains a set of criteria
            which will be used to determine the warn/error limits for the
            various modules.  This file can also be used to selectively
            remove some modules from the output all together.  The format
            needs to mirror the default limits.txt file found in the
            Configuration folder.
        kmers:
          type:
            - "null"
            - int
          inputBinding:
            position: 11
            prefix: '--kmers'
          doc: |
            Specifies the length of Kmer to look for in the Kmer content
            module. Specified Kmer length must be between 2 and 10. Default
            length is 7 if not specified.
        casava:
          type:
            - "null"
            - boolean
          inputBinding:
            position: 13
            prefix: '--casava'
          doc: |
            Files come from raw casava output. Files in the same sample
            group (differing only by the group number) will be analysed
            as a set rather than individually. Sequences with the filter
            flag set in the header will be excluded from the analysis.
            Files must have the same names given to them by casava
            (including being gzipped and ending with .gz) otherwise they
            won't be grouped together correctly.
        nofilter:
          type:
            - "null"
            - boolean
          inputBinding:
            position: 14
            prefix: '--nofilter'
          doc: |
            If running with --casava then don't remove read flagged by
            casava as poor quality when performing the QC analysis.
        hide_group:
          type:
            - "null"
            - boolean
          inputBinding:
            position: 15
            prefix: '--nogroup'
          doc: |
            Disable grouping of bases for reads >50bp. All reports will
            show data for every base in the read.  WARNING: Using this
            option will cause fastqc to crash and burn if you use it on
            really long reads, and your plots may end up a ridiculous size.
            You have been warned!
      outputs:
        zipped_file:
          type:
            - File
          outputBinding:
            glob: '*.zip'
        html_file:
          type:
            - File
          outputBinding:
            glob: '*.html'
        summary_file:
          type:
            - File
          outputBinding:
            glob: |
              ${
                return "*/summary.txt";
              }
      baseCommand: [fastqc, --extract, --outdir, .]
    in:
      reads_file: extract_fastq_2/fastq_file
    out:
      - summary_file
      - html_file

  rename_qc_fastq_2_report:
    run:
      cwlVersion: v1.0
      class: CommandLineTool
      requirements:
      - class: InlineJavascriptRequirement
        expressionLib:
        - var get_target_name = function() {
              return inputs.target_filename.split('/').slice(-1)[0];
          }
      hints:
      - class: DockerRequirement
        dockerPull: biowardrobe2/scidap:v0.0.2
      inputs:
        source_file:
          type: File
          inputBinding:
            position: 5
        target_filename:
          type: string
          inputBinding:
            position: 6
            valueFrom: $(get_target_name())
      outputs:
        target_file:
          type: File
          outputBinding:
            glob: $(get_target_name())
      baseCommand: ["cp"]
    in:
      source_file: qc_fastq_2/html_file
      target_filename:
        source: fastq_file_2
        valueFrom: $(get_root(self.basename)+"_qc_original.html")
    out: [target_file]

  trigger_fastq_2_adapter_trimming:
    run:
      cwlVersion: v1.0
      class: ExpressionTool
      requirements:
        - class: InlineJavascriptRequirement
      id: "fastqc_results_trigger"
      inputs:
        summary_file:
          type: File
          inputBinding:
            loadContents: true
      outputs:
        trigger: boolean
      expression: |
        ${
          var criteria_array = inputs.summary_file.contents.match(/.*Per base sequence quality.*|.*Per sequence quality scores.*|.*Overrepresented sequences.*|.*Adapter Content.*/g);
          if (criteria_array.length > 0){
            if (criteria_array.toString().match(/FAIL/g) != null){
              return { "trigger": true };
            } else {
              return { "trigger": false };
            }
          } else {
            return { "trigger": true };
          }
        }
    in:
      summary_file: qc_fastq_2/summary_file
    out: [trigger]


# -----------------------------------------------------------------------------------


  trim_adapters:
    run:
      cwlVersion: v1.0
      class: CommandLineTool
      requirements:
      - class: InlineJavascriptRequirement
        expressionLib:
        - var default_log_name = function() {
            var lognames = {};
            lognames["pair"] = (inputs.paired && inputs.input_file_pair) ? inputs.input_file_pair.basename+'_trimming_report.txt':null;
            lognames["single"] = inputs.input_file.basename+'_trimming_report.txt';
            return lognames;
          }
      - class: InitialWorkDirRequirement
        listing: |
          ${
            var listing = [inputs.input_file]
            if (inputs.input_file_pair){
              listing.push(inputs.input_file_pair);
            }
            return listing;
          }
      hints:
      - class: DockerRequirement
        dockerPull: biowardrobe2/trimgalore:v0.4.4
      inputs:
        bash_script:
          type: string?
          default: |
            #!/bin/bash
            if [ "$0" = "true" ]
            then
              echo "Run: trimgalore " ${@:1}
              trim_galore "${@:1}"
            else
              echo "Skip run trimgalore"
            fi
          inputBinding:
            position: 1
          doc: |
            Bash function to run trimgalore with all input parameters or skip it if trigger is false
        trigger:
          type: boolean?
          default: true
          inputBinding:
            position: 2
            valueFrom: $(self?"true":"false")
          doc: |
            If true - run trimgalore, if false - return input fastq files, previously staged into output directory.
            Use valueFrom to return string instead of boolean to make sure that value is printed to command line in both cases
        input_file:
          type:
            - File
          inputBinding:
            position: 100
          doc: |
            Input FASTQ file
        input_file_pair:
          type:
            - "null"
            - File
          inputBinding:
            position: 101
            valueFrom: |
              ${
                  if (!inputs.paired){
                    return null;
                  } else {
                    return self;
                  }
              }
          doc: |
            Input FASTQ file, if paired-end data is analysed
        quality:
          type:
            - "null"
            - int
          inputBinding:
            position: 5
            prefix: '-q'
          doc: |
            Trim low-quality ends from reads in addition to adapter removal.
            Default Phred score: 20.
        phred33:
          type:
            - "null"
            - boolean
          inputBinding:
            position: 6
            prefix: '--phred33'
          doc: |
            Instructs Cutadapt to use ASCII+33 quality scores as Phred scores
            (Sanger/Illumina 1.9+ encoding) for quality trimming.
            Default: ON.
        phred64:
          type:
            - "null"
            - boolean
          inputBinding:
            position: 7
            prefix: '--phred64'
          doc: |
              Instructs Cutadapt to use ASCII+64 quality scores as Phred scores
              (Illumina 1.5 encoding) for quality trimming.
        adapter:
          type:
            - "null"
            - string
          inputBinding:
            position: 10
            prefix: '-a'
          doc: |
            Adapter sequence to be trimmed. If not specified explicitly, Trim Galore will
            try to auto-detect whether the Illumina universal, Nextera transposase or Illumina
            small RNA adapter sequence was used. Also see '--illumina', '--nextera' and
            '--small_rna'. If no adapter can be detected within the first 1 million sequences
            of the first file specified Trim Galore defaults to '--illumina'.
        adapter_pair:
          type:
            - "null"
            - string
          inputBinding:
            position: 11
            prefix: '-a2'
          doc: |
            Optional adapter sequence to be trimmed off read 2 of paired-end files. This
            option requires '--paired' to be specified as well. If the libraries to be trimmed
            are smallRNA then a2 will be set to the Illumina small RNA 5' adapter automatically
            (GATCGTCGGACT).
        illumina:
          type:
            - "null"
            - boolean
          inputBinding:
            position: 12
            prefix: '--illumina'
          doc: |
              Adapter sequence to be trimmed is the first 13bp of the Illumina universal adapter
              'AGATCGGAAGAGC' instead of the default auto-detection of adapter sequence.
        nextera:
          type:
            - "null"
            - boolean
          inputBinding:
            position: 13
            prefix: '--nextera'
          doc: |
              Adapter sequence to be trimmed is the first 12bp of the Nextera adapter
              'CTGTCTCTTATA' instead of the default auto-detection of adapter sequence.
        small_rna:
          type:
            - "null"
            - boolean
          inputBinding:
            position: 14
            prefix: '--small_rna'
          doc: |
              Adapter sequence to be trimmed is the first 12bp of the Illumina Small RNA 3' Adapter
              'TGGAATTCTCGG' instead of the default auto-detection of adapter sequence. Selecting
              to trim smallRNA adapters will also lower the --length value to 18bp. If the smallRNA
              libraries are paired-end then a2 will be set to the Illumina small RNA 5' adapter
              automatically (GATCGTCGGACT) unless -a 2 had been defined explicitly.
        max_length:
          type:
            - "null"
            - int
          inputBinding:
            position: 15
            prefix: '--max_length'
          doc: |
            Discard reads that are longer than <INT> bp after trimming. This is only advised for
            smallRNA sequencing to remove non-small RNA sequences.
        stringency:
          type:
            - "null"
            - int
          inputBinding:
            position: 16
            prefix: '--stringency'
          doc: |
            Overlap with adapter sequence required to trim a sequence. Defaults to a
            very stringent setting of 1, i.e. even a single bp of overlapping sequence
            will be trimmed off from the 3' end of any read.
        error_rate:
          type:
            - "null"
            - float
          inputBinding:
            position: 17
            prefix: '-e'
          doc: |
            Maximum allowed error rate (no. of errors divided by the length of the matching region)
            Default: 0.1
        gzip:
          type:
            - "null"
            - boolean
          inputBinding:
            position: 18
            prefix: '--gzip'
          doc: |
            Compress the output file with GZIP. If the input files are GZIP-compressed
            the output files will automatically be GZIP compressed as well. As of v0.2.8 the
            compression will take place on the fly.
        dont_gzip:
          type:
            - "null"
            - boolean
          inputBinding:
            position: 19
            prefix: '--dont_gzip'
          doc: |
            Output files won't be compressed with GZIP. This option overrides --gzip.
        length:
          type:
            - "null"
            - int
          inputBinding:
            position: 20
            prefix: '--length'
          doc: |
            Discard reads that became shorter than length INT because of either
            quality or adapter trimming. A value of '0' effectively disables
            this behaviour.
            Default: 20 bp.
        max_n:
          type:
            - "null"
            - int
          inputBinding:
            position: 21
            prefix: '--max_n'
          doc: |
            The total number of Ns (as integer) a read may contain before it will be removed altogether.
            In a paired-end setting, either read exceeding this limit will result in the entire
            pair being removed from the trimmed output files.
        trim_n:
          type:
            - "null"
            - boolean
          inputBinding:
            position: 22
            prefix: '--trim-n'
          doc: |
            Removes Ns from either side of the read. This option does currently not work in RRBS mode.
        no_report_file:
          type:
            - "null"
            - boolean
          inputBinding:
            position: 23
            prefix: '--no_report_file'
          doc: |
            If specified no report file will be generated.
        suppress_warn:
          type:
            - "null"
            - boolean
          inputBinding:
            position: 24
            prefix: '--suppress_warn'
          doc: |
            If specified any output to STDOUT or STDERR will be suppressed.
        clip_R1:
          type:
            - "null"
            - int
          inputBinding:
            position: 25
            prefix: '--clip_R1'
          doc: |
            Instructs Trim Galore to remove <int> bp from the 5' end of read 1 (or single-end
            reads). This may be useful if the qualities were very poor, or if there is some
            sort of unwanted bias at the 5' end.
            Default: OFF.
        clip_R2:
          type:
            - "null"
            - int
          inputBinding:
            position: 26
            prefix: '--clip_R2'
          doc: |
            Instructs Trim Galore to remove <int> bp from the 5' end of read 2 (paired-end reads
            only). This may be useful if the qualities were very poor, or if there is some sort
            of unwanted bias at the 5' end. For paired-end BS-Seq, it is recommended to remove
            the first few bp because the end-repair reaction may introduce a bias towards low
            methylation. Please refer to the M-bias plot section in the Bismark User Guide for
            some examples.
            Default: OFF.
        three_prime_clip_R1:
          type:
            - "null"
            - int
          inputBinding:
            position: 27
            prefix: '--three_prime_clip_R1'
          doc: |
            Instructs Trim Galore to remove <int> bp from the 3' end of read 1 (or single-end
            reads) AFTER adapter/quality trimming has been performed. This may remove some unwanted
            bias from the 3' end that is not directly related to adapter sequence or basecall quality.
            Default: OFF.
        three_prime_clip_R2:
          type:
            - "null"
            - int
          inputBinding:
            position: 28
            prefix: '--three_prime_clip_R2'
          doc: |
            Instructs Trim Galore to remove <int> bp from the 3' end of read 2 AFTER
            adapter/quality trimming has been performed. This may remove some unwanted bias from
            the 3' end that is not directly related to adapter sequence or basecall quality.
            Default: OFF.
        rrbs:
          type:
            - "null"
            - boolean
          inputBinding:
            position: 29
            prefix: '--rrbs'
          doc: |
            Specifies that the input file was an MspI digested RRBS sample (recognition
            site: CCGG). Single-end or Read 1 sequences (paired-end) which were adapter-trimmed
            will have a further 2 bp removed from their 3' end. Sequences which were merely
            trimmed because of poor quality will not be shortened further. Read 2 of paired-end
            libraries will in addition have the first 2 bp removed from the 5' end (by setting
            '--clip_r2 2'). This is to avoid using artificial methylation calls from the filled-in
            cytosine positions close to the 3' MspI site in sequenced fragments.
            This option is not recommended for users of the NuGEN ovation RRBS System 1-16
            kit (see below).
        non_directional:
          type:
            - "null"
            - boolean
          inputBinding:
            position: 30
            prefix: '--non_directional'
          doc: |
            Selecting this option for non-directional RRBS libraries will screen
            quality-trimmed sequences for 'CAA' or 'CGA' at the start of the read
            and, if found, removes the first two basepairs. Like with the option
            '--rrbs' this avoids using cytosine positions that were filled-in
            during the end-repair step. '--non_directional' requires '--rrbs' to
            be specified as well. Note that this option does not set '--clip_r2 2' in
            paired-end mode.
        paired:
          type:
            - "null"
            - boolean
          inputBinding:
            position: 32
            prefix: '--paired'
            valueFrom: |
              ${
                  if (!inputs.input_file_pair){
                    return null;
                  } else {
                    return self;
                  }
              }
          doc: |
            This option performs length trimming of quality/adapter/RRBS trimmed reads for
            paired-end files. To pass the validation test, both sequences of a sequence pair
            are required to have a certain minimum length which is governed by the option
            --length (see above). If only one read passes this length threshold the
            other read can be rescued (see option --retain_unpaired). Using this option vars
            you discard too short read pairs without disturbing the sequence-by-sequence order
            of FastQ files which is required by many aligners.
        trim1:
          type:
            - "null"
            - boolean
          inputBinding:
            position: 33
            prefix: '--trim1'
          doc: |
            Trims 1 bp off every read from its 3' end. This may be needed for FastQ files that
            are to be aligned as paired-end data with Bowtie.
      # NOTE influence on output
        retain_unpaired:
          type:
            - "null"
            - boolean
          inputBinding:
            position: 34
            prefix: '--retain_unpaired'
          doc: |
            If only one of the two paired-end reads became too short, the longer
            read will be written to either '.unpaired_1.fq' or '.unpaired_2.fq'
            output files. The length cutoff for unpaired single-end reads is
            governed by the parameters -r1/--length_1 and -r2/--length_2.
            Default: OFF.
        length_1:
          type:
            - "null"
            - int
          inputBinding:
            position: 35
            prefix: '-r1'
          doc: |
            Unpaired single-end read length cutoff needed for read 1 to be written to
            '.unpaired_1.fq' output file. These reads may be mapped in single-end mode.
            Default: 35 bp.
        length_2:
          type:
            - "null"
            - int
          inputBinding:
            position: 36
            prefix: '-r2'
          doc: |
            Unpaired single-end read length cutoff needed for read 2 to be written to
            '.unpaired_2.fq' output file. These reads may be mapped in single-end mode.
            Default: 35 bp.
      outputs:
        trimmed_file:
          type: File
          outputBinding:
            glob: |
              ${
                  if (inputs.trigger == false){
                    return inputs.input_file.basename;
                  } else if (inputs.paired && inputs.input_file_pair){
                    return "*_val_1.fq*";
                  } else {
                    return "*_trimmed.fq*";
                  }
              }
        trimmed_file_pair:
          type: File?
          outputBinding:
            glob: |
              ${
                  if (inputs.paired && inputs.input_file_pair && inputs.trigger == false){
                    return inputs.input_file_pair.basename;
                  } else {
                    return "*_val_2.fq*";
                  }
              }
        unpaired_file_1:
          type: File?
          outputBinding:
            glob: "*_unpaired_1.fq*"
        unpaired_file_2:
          type: File?
          outputBinding:
            glob: "*_unpaired_2.fq*"
        report_file:
          type: File?
          outputBinding:
            glob: $(default_log_name()['single'])
        report_file_pair:
          type: File?
          outputBinding:
            glob: $(default_log_name()['pair'])
      baseCommand: [bash, '-c']
    in:
      trigger:
        source: [trigger_fastq_1_adapter_trimming/trigger, trigger_fastq_2_adapter_trimming/trigger]
        valueFrom: $(self[0] || self[1])               # run trimgalore if at least one of input fastq files failed quality check
      input_file: extract_fastq_1/fastq_file
      input_file_pair: extract_fastq_2/fastq_file
      quality:
        default: 30      # Why do we need it if default should be 20
      dont_gzip:
        default: true    # should make it faster
      length:
        default: 30      # discard all reads shorter than 30 bp
      paired:
        default: true
    out:
      - trimmed_file
      - trimmed_file_pair
      - report_file
      - report_file_pair


# -----------------------------------------------------------------------------------


  rename_trimmed_fastq_1:
    run:
      cwlVersion: v1.0
      class: CommandLineTool
      requirements:
      - class: InlineJavascriptRequirement
        expressionLib:
        - var get_target_name = function() {
              return inputs.target_filename.split('/').slice(-1)[0];
          }
      hints:
      - class: DockerRequirement
        dockerPull: biowardrobe2/scidap:v0.0.2
      inputs:
        source_file:
          type: File
          inputBinding:
            position: 5
        target_filename:
          type: string
          inputBinding:
            position: 6
            valueFrom: $(get_target_name())
      outputs:
        target_file:
          type: File
          outputBinding:
            glob: $(get_target_name())
      baseCommand: ["cp"]
    in:
      source_file: trim_adapters/trimmed_file
      target_filename:
        source: fastq_file_1
        valueFrom: $(get_root(self.basename) + ".fastq")
    out: [target_file]

  rename_trimmed_fastq_2:
    run:
      cwlVersion: v1.0
      class: CommandLineTool
      requirements:
      - class: InlineJavascriptRequirement
        expressionLib:
        - var get_target_name = function() {
              return inputs.target_filename.split('/').slice(-1)[0];
          }
      hints:
      - class: DockerRequirement
        dockerPull: biowardrobe2/scidap:v0.0.2
      inputs:
        source_file:
          type: File
          inputBinding:
            position: 5
        target_filename:
          type: string
          inputBinding:
            position: 6
            valueFrom: $(get_target_name())
      outputs:
        target_file:
          type: File
          outputBinding:
            glob: $(get_target_name())
      baseCommand: ["cp"]
    in:
      source_file: trim_adapters/trimmed_file_pair
      target_filename:
        source: fastq_file_2
        valueFrom: $(get_root(self.basename) + ".fastq")
    out: [target_file]


# -----------------------------------------------------------------------------------


  align_reads:
    run:
      cwlVersion: v1.0
      class: CommandLineTool
      requirements:
      - class: ShellCommandRequirement
      - class: InlineJavascriptRequirement
        expressionLib:
        - var default_output_filename = function() {
              if (Array.isArray(inputs.filelist) && inputs.filelist.length > 0){
                return inputs.filelist[0].location.split('/').slice(-1)[0].split('.').slice(0,-1).join('.')+".sam";
              } else
                if (inputs.filelist != null){
                  return inputs.filelist.location.split('/').slice(-1)[0].split('.').slice(0,-1).join('.')+".sam";
                } else
                  if (Array.isArray(inputs.filelist_mates) && inputs.filelist_mates.length > 0){
                    return inputs.filelist_mates[0].location.split('/').slice(-1)[0].split('.').slice(0,-1).join('.')+".sam";
                  } else
                    if (inputs.filelist_mates != null){
                      return inputs.filelist_mates.location.split('/').slice(-1)[0].split('.').slice(0,-1).join('.')+".sam";
                    } else {
                      return null;
                    }
          };
      hints:
      - class: DockerRequirement
        dockerPull: biowardrobe2/bowtie2:v2.3.0
        dockerFile: >
          $import: ./dockerfiles/bowtie2-Dockerfile
      inputs:
        indices_folder:
          type: Directory
          doc: >
            Folder with indices files
          inputBinding:
            position: 81
            prefix: '-x'
            valueFrom: |
              ${
                  for (var i = 0; i < self.listing.length; i++) {
                      if (self.listing[i].path.split('.').slice(-3).join('.') == 'rev.1.bt2' ||
                          self.listing[i].path.split('.').slice(-3).join('.') == 'rev.1.bt2l'){
                        return self.listing[i].path.split('.').slice(0,-3).join('.');
                      }
                  }
                  return null;
              }
        filelist:
          type:
          - "null"
          - File
          - type: array
            items: File
          doc: |
            {-1 <m1> -2 <m2> | -U <r>} [-S <sam>]
            <m1>       Files with #1 mates, paired with files in <m2>.
                      Could be gzip'ed (extension: .gz) or bzip2'ed (extension: .bz2).
            <m2>       Files with #2 mates, paired with files in <m1>.
                      Could be gzip'ed (extension: .gz) or bzip2'ed (extension: .bz2).
            <r>        Files with unpaired reads.
                      Could be gzip'ed (extension: .gz) or bzip2'ed (extension: .bz2).
          inputBinding:
            itemSeparator: ","
            position: 83
        filelist_mates:
          type:
          - "null"
          - File
          - type: array
            items: File
          inputBinding:
            itemSeparator: ","
            position: 85
        output_filename:
          type: string
          inputBinding:
            position: 90
            prefix: "-S"
            valueFrom: |
              ${
                  if (self == ""){
                    return default_output_filename();
                  } else {
                    return self;
                  }
              }
          default: ""
          doc: |
            File for SAM output (default: stdout)
        q:
          type:
          - "null"
          - boolean
          doc: "query input files are FASTQ .fq/.fastq (default)"
          inputBinding:
            position: 1
            prefix: '-q'
        qseq:
          type:
          - "null"
          - boolean
          doc: "query input files are in Illumina's qseq format"
          inputBinding:
            position: 1
            prefix: '--qseq'
        f:
          type:
          - "null"
          - boolean
          doc: "query input files are (multi-)FASTA .fa/.mfa"
          inputBinding:
            position: 1
            prefix: '-f'
        raw:
          type:
          - "null"
          - boolean
          doc: "query input files are raw one-sequence-per-line"
          inputBinding:
            position: 1
            prefix: '-r'
        c:
          type:
          - "null"
          - boolean
          doc: "<m1>, <m2>, <r> are sequences themselves, not files"
          inputBinding:
            position: 1
            prefix: '-c'
        s:
          type:
          - "null"
          - int
          doc: |
            skip the first <int> reads/pairs in the input (none)
          inputBinding:
            position: 2
            prefix: '-s'
        u:
          type:
          - "null"
          - int
          doc: |
            stop after first <int> reads/pairs (no limit)
          inputBinding:
            position: 3
            prefix: '-u'
        clip_5p_end:
          type: int?
          doc: |
            trim <int> bases from 5'/left end of reads (0)
          inputBinding:
            position: 4
            prefix: '-5'
        clip_3p_end:
          type: int?
          doc: |
            trim <int> bases from 3'/right end of reads (0)
          inputBinding:
            position: 5
            prefix: '-3'
        phred33_quals:
          type:
          - "null"
          - boolean
          doc: "qualities are Phred+33 (default)"
          inputBinding:
            position: 6
            prefix: '--phred33'
        phred64_quals:
          type:
          - "null"
          - boolean
          doc: "qualities are Phred+64"
          inputBinding:
            position: 6
            prefix: '--phred64'
        integer_quals:
          type:
          - "null"
          - boolean
          doc: "qualities encoded as space-delimited integers"
          inputBinding:
            position: 6
            prefix: '--int-quals'
        n:
          type:
          - "null"
          - int
          doc: |
            max # mismatches in seed alignment; can be 0 or 1 (0)
          inputBinding:
            position: 7
            prefix: '-N'
        l:
          type:
          - "null"
          - int
          doc: |
            length of seed substrings; must be >3, <32 (22)
          inputBinding:
            position: 8
            prefix: '-L'
        i:
          type:
          - "null"
          - int
          doc: |
            interval between seed substrings w/r/t read len (S,1,1.15)
          inputBinding:
            position: 9
            prefix: '-i'
        n_ceil:
          type:
          - "null"
          - string
          doc: >
            func for max # non-A/C/G/Ts permitted in aln (L,0,0.15)
          inputBinding:
            position: 10
            prefix: '--n-ceil'
        dpad:
          type:
          - "null"
          - int
          doc: |
            include <int> extra ref chars on sides of DP table (15)
          inputBinding:
            position: 11
            prefix: '--dpad'
        gbar:
          type:
          - "null"
          - int
          doc: |
            disallow gaps within <int> nucs of read extremes (4)
          inputBinding:
            position: 12
            prefix: '--gbar'
        ignore_quals:
          type:
          - "null"
          - boolean
          doc: |
            treat all quality values as 30 on Phred scale (off)
          inputBinding:
            position: 13
            prefix: '--ignore-quals'
        nofw:
          type:
          - "null"
          - boolean
          doc: |
            do not align forward (original) version of read (off)
          inputBinding:
            position: 14
            prefix: '--nofw'
        norc:
          type:
          - "null"
          - boolean
          doc: |
            do not align reverse-complement version of read (off)
          inputBinding:
            position: 15
            prefix: '--norc'
        no_1mm_upfront:
          type:
          - "null"
          - boolean
          doc: |
            do not allow 1 mismatch alignments before attempting to scan for the optimal seeded alignments
          inputBinding:
            position: 16
            prefix: '--no-1mm-upfront'
        end_to_end:
          type:
          - "null"
          - boolean
          doc: |
            entire read must align; no clipping (on)
            Options:
              --very-fast            -D 5 -R 1 -N 0 -L 22 -i S,0,2.50
              --fast                 -D 10 -R 2 -N 0 -L 22 -i S,0,2.50
              --sensitive            -D 15 -R 2 -N 0 -L 22 -i S,1,1.15 (default)
              --very-sensitive       -D 20 -R 3 -N 0 -L 20 -i S,1,0.50
          inputBinding:
            position: 17
            prefix: '--end-to-end'
        end_to_end_very_fast:
          type:
          - "null"
          - boolean
          doc: |
            Option for end_to_end:
              --very-fast            -D 5 -R 1 -N 0 -L 22 -i S,0,2.50
          inputBinding:
            position: 18
            prefix: '--very-fast'
        end_to_end_fast:
          type:
          - "null"
          - boolean
          doc: |
            Option for end_to_end:
              --very-fast            -D 5 -R 1 -N 0 -L 22 -i S,0,2.50
          inputBinding:
            position: 18
            prefix: '--fast'
        end_to_end_sensitive:
          type:
          - "null"
          - boolean
          doc: |
            Option for end_to_end:
              --sensitive            -D 15 -R 2 -N 0 -L 22 -i S,1,1.15 (default)
          inputBinding:
            position: 18
            prefix: '--sensitive'
        end_to_end_very_sensitive:
          type:
          - "null"
          - boolean
          doc: |
            Option for end_to_end:
              --very-sensitive       -D 20 -R 3 -N 0 -L 20 -i S,1,0.50
          inputBinding:
            position: 18
            prefix: '--very-sensitive'
        local:
          type:
          - "null"
          - boolean
          doc: |
            local alignment; ends might be soft clipped (off)
            Options:
              --very-fast-local      -D 5 -R 1 -N 0 -L 25 -i S,1,2.00
              --fast-local           -D 10 -R 2 -N 0 -L 22 -i S,1,1.75
              --sensitive-local      -D 15 -R 2 -N 0 -L 20 -i S,1,0.75 (default)
              --very-sensitive-local -D 20 -R 3 -N 0 -L 20 -i S,1,0.50
          inputBinding:
            position: 19
            prefix: '--local'
        local_very_fast_local:
          type:
          - "null"
          - boolean
          doc: |
            Option for local:
              --very-fast-local      -D 5 -R 1 -N 0 -L 25 -i S,1,2.00
          inputBinding:
            position: 20
            prefix: '--very-fast-local'
        local_fast_local:
          type:
          - "null"
          - boolean
          doc: |
            Option for local:
              --fast-local           -D 10 -R 2 -N 0 -L 22 -i S,1,1.75
          inputBinding:
            position: 20
            prefix: '--fast-local'
        local_sensitive_local:
          type:
          - "null"
          - boolean
          doc: |
            Option for local:
              --sensitive-local      -D 15 -R 2 -N 0 -L 20 -i S,1,0.75 (default)
          inputBinding:
            position: 20
            prefix: '--sensitive-local'
        local_very_sensitive_local:
          type:
          - "null"
          - boolean
          doc: |
            Option for local:
              --very-sensitive-local -D 20 -R 3 -N 0 -L 20 -i S,1,0.50
          inputBinding:
            position: 20
            prefix: '--very-sensitive-local'
        ma:
          type:
          - "null"
          - int
          doc: |
            match bonus (0 for --end-to-end, 2 for --local)
          inputBinding:
            position: 21
            prefix: '--ma'
        mp:
          type:
          - "null"
          - int
          doc: |
            max penalty for mismatch; lower qual = lower penalty (6)
          inputBinding:
            position: 22
            prefix: '--mp'
        np:
          type:
          - "null"
          - int
          doc: |
            penalty for non-A/C/G/Ts in read/ref (1)
          inputBinding:
            position: 23
            prefix: '--np'
        rdg:
          type:
          - "null"
          - int[]
          doc: |
            read gap open, extend penalties (5,3)
          inputBinding:
            position: 24
            itemSeparator: ","
            prefix: '--rdg'
        rfg:
          type:
          - "null"
          - int[]
          doc: |
            reference gap open, extend penalties (5,3)
          inputBinding:
            position: 25
            itemSeparator: ","
            prefix: '--rfg'
        score_min:
          type:
          - "null"
          - string
          doc: |
            min acceptable alignment score w/r/t read length (G,20,8 for local, L,-0.6,-0.6 for end-to-end)
          inputBinding:
            position: 26
            prefix: '--score-min'
        k:
          type:
          - "null"
          - int
          doc: |
            report up to <int> alns per read; MAPQ not meaningful
          inputBinding:
            position: 27
            prefix: '-k'
        a:
          type:
          - "null"
          - boolean
          doc: |
            report all alignments; very slow, MAPQ not meaningful
          inputBinding:
            position: 27
            prefix: '-a'
        d:
          type:
          - "null"
          - int
          doc: |
            give up extending after <int> failed extends in a row (15)
          inputBinding:
            position: 28
            prefix: '-D'
        r:
          type:
          - "null"
          - int
          doc: |
            for reads w/ repetitive seeds, try <int> sets of seeds (2)
          inputBinding:
            position: 29
            prefix: '-R'
        minins:
          type:
          - "null"
          - int
          doc: |
            minimum fragment length (0)
          inputBinding:
            position: 30
            prefix: '--minins'
        maxins:
          type:
          - "null"
          - int
          doc: |
            maxins fragment length (0)
          inputBinding:
            position: 30
            prefix: '--maxins'
        fr:
          type:
          - "null"
          - boolean
          doc: |
            -1, -2 mates align fw/rev, rev/fw, fw/fw (--fr)
          inputBinding:
            position: 31
            prefix: '--fr'
        rf:
          type:
          - "null"
          - boolean
          doc: |
            -1, -2 mates align fw/rev, rev/fw, fw/fw (--fr)
          inputBinding:
            position: 31
            prefix: '--rf'
        ff:
          type:
          - "null"
          - boolean
          doc: |
            -1, -2 mates align fw/rev, rev/fw, fw/fw (--fr)
          inputBinding:
            position: 31
            prefix: '--ff'
        no_mixed:
          type:
          - "null"
          - boolean
          doc: |
            suppress unpaired alignments for paired reads
          inputBinding:
            position: 32
            prefix: '--no-mixed'
        no_discordant:
          type:
          - "null"
          - boolean
          doc: |
            suppress discordant alignments for paired reads
          inputBinding:
            position: 33
            prefix: '--no-discordant'
        no_dovetail:
          type:
          - "null"
          - boolean
          doc: |
            not concordant when mates extend past each other
          inputBinding:
            position: 34
            prefix: '--no-dovetail'
        no_contain:
          type:
          - "null"
          - boolean
          doc: |
            not concordant when one mate alignment contains other
          inputBinding:
            position: 35
            prefix: '--no-contain'
        no_overlap:
          type:
          - "null"
          - boolean
          doc: |
            not concordant when mates overlap at all
          inputBinding:
            position: 36
            prefix: '--no-overlap'
        t:
          type:
          - "null"
          - boolean
          doc: |
            print wall-clock time taken by search phases
          inputBinding:
            position: 37
            prefix: '-t'
        un:
          type:
          - "null"
          - string
          doc: |
            write unpaired reads that didn't align to <path>
          inputBinding:
            position: 38
            prefix: '--un'
        al:
          type:
          - "null"
          - string
          doc: |
            write unpaired reads that aligned at least once to <path>
          inputBinding:
            position: 39
            prefix: '--al'
        un_conc:
          type:
          - "null"
          - string
          doc: |
            write pairs that didn't align concordantly to <path>
          inputBinding:
            position: 40
            prefix: '--un-conc'
        al_conc:
          type:
          - "null"
          - string
          doc: |
            write pairs that aligned concordantly at least once to <path>
          inputBinding:
            position: 41
            prefix: '--al-conc'
        quiet:
          type:
          - "null"
          - boolean
          doc: "print nothing to stderr except serious errors"
          inputBinding:
            position: 42
            prefix: '--quiet'
        met_file:
          type:
          - "null"
          - string
          doc: |
            send metrics to file at <path> (off)
          inputBinding:
            position: 43
            prefix: '--met-file'
        met_stderr:
          type:
          - "null"
          - boolean
          doc: "send metrics to stderr (off)"
          inputBinding:
            position: 44
            prefix: '--met-stderr'
        met:
          type:
          - "null"
          - int
          doc: |
            report internal counters & metrics every <int> secs (1)
          inputBinding:
            position: 45
            prefix: '--met'
        no_unal:
          type:
          - "null"
          - boolean
          doc: "suppress SAM records for unaligned reads"
          inputBinding:
            position: 46
            prefix: '--no-unal'
        no_head:
          type:
          - "null"
          - boolean
          doc: "suppress header lines, i.e. lines starting with @"
          inputBinding:
            position: 47
            prefix: '--no-head'
        no_sq:
          type:
          - "null"
          - boolean
          doc: "suppress @SQ header lines"
          inputBinding:
            position: 48
            prefix: '--no-sq'
        rg_id:
          type:
          - "null"
          - string
          doc: "set read group id, reflected in @RG line and RG:Z: opt field"
          inputBinding:
            position: 49
            prefix: '--rg-id'
        rg:
          type:
          - "null"
          - string
          doc: |
            add <text> ("lab:value") to @RG line of SAM header.
            Note: @RG line only printed when --rg-id is set.
          inputBinding:
            position: 50
            prefix: '--rg'
        omit_sec_seq:
          type:
          - "null"
          - boolean
          doc: "put '*' in SEQ and QUAL fields for secondary alignments"
          inputBinding:
            position: 51
            prefix: '--omit-sec-seq'
        threads:
          type:
          - "null"
          - int
          doc: |
            number of alignment threads to launch (1)
          inputBinding:
            position: 52
            prefix: '-p'
        reorder:
          type:
          - "null"
          - boolean
          doc: |
            force SAM output order to match order of input reads
          inputBinding:
            position: 53
            prefix: '--reorder'
        mm:
          type:
          - "null"
          - boolean
          doc: "use memory-mapped I/O for index; many 'bowtie's can share"
          inputBinding:
            position: 54
            prefix: '--mm'
        qc_filter:
          type:
          - "null"
          - boolean
          doc: "filter out reads that are bad according to QSEQ filter"
          inputBinding:
            position: 55
            prefix: '--qc-filter'
      #
        seed:
          type:
          - "null"
          - int
          doc: |
            seed for random number generator (0)
          inputBinding:
            position: 56
            prefix: '--seed'
        non_deterministic:
          type:
          - "null"
          - boolean
          doc: "seed rand. gen. arbitrarily instead of using read attributes"
          inputBinding:
            position: 57
            prefix: '--non-deterministic'
      outputs:
        output:
          type: File
          outputBinding:
            glob: |
              ${
                if (inputs.output_filename == ""){
                  return default_output_filename();
                } else {
                  return inputs.output_filename;
                }
              }
        output_log:
          type: File
          outputBinding:
            glob: |
              ${
                if (inputs.output_filename == ""){
                  return default_output_filename().split('.').slice(0,-1).join('.') + ".log";
                } else {
                  return inputs.output_filename.split('.').slice(0,-1).join('.') + ".log";
                }
              }
      baseCommand:
        - bowtie2
      arguments:
        - valueFrom: |
            ${
              if (inputs.filelist && inputs.filelist_mates){
                return "-1";
              } else if (inputs.filelist){
                return "-U";
              } else {
                return null;
              }
            }
          position: 82
        - valueFrom: |
            ${
              if (inputs.filelist && inputs.filelist_mates){
                return "-2";
              } else if (inputs.filelist_mates){
                return "-U";
              } else {
                return null;
              }
            }
          position: 84
        - valueFrom: |
            ${
              if (inputs.output_filename == ""){
                return ' 2> ' + default_output_filename().split('.').slice(0,-1).join('.') + '.log';
              } else {
                return ' 2> ' + inputs.output_filename.split('.').slice(0,-1).join('.') + '.log';
              }
            }
          position: 100000
          shellQuote: false
    in:
      filelist: rename_trimmed_fastq_1/target_file
      filelist_mates: rename_trimmed_fastq_2/target_file
      indices_folder: indices_folder
      end_to_end_very_sensitive:
        default: true
      maxins:
        default: 2000
      no_discordant:          # do we need it?
        default: true
      no_mixed:               # do we need it?
        default: true
      threads: threads
    out:
      - output
      - output_log

  sort_and_index:
    run:
      cwlVersion: v1.0
      class: CommandLineTool
      requirements:
      - class: ShellCommandRequirement
      - class: InitialWorkDirRequirement
        listing: |
          ${
            return  [
                      {
                        "entry": inputs.sort_input,
                        "entryname": inputs.sort_input.basename,
                        "writable": true
                      }
                    ]
          }
      - class: InlineJavascriptRequirement
        expressionLib:
        - var ext = function() {
            if (inputs.csi && !inputs.bai){
              return '.csi';
            } else {
              return '.bai';
            }
          };
        - var default_bam = function() {
            if (inputs.trigger == true){
              return inputs.sort_input.location.split('/').slice(-1)[0].split('.').slice(0,-1).join('.')+".bam";
            } else {
              return inputs.sort_input.location.split('/').slice(-1)[0];
            }
          };
      hints:
      - class: DockerRequirement
        dockerPull: biowardrobe2/samtools:v1.4
      inputs:
        bash_script_sort:
          type: string?
          default: |
            #!/bin/bash
            if [ "$0" = "true" ]
            then
              echo "Run: samtools sort " ${@:1}
              samtools sort "${@:1}"
            else
              echo "Skip samtools sort " ${@:1}
            fi
          inputBinding:
            position: 5
          doc: |
            Bash function to run samtools sort with all input parameters or skip it if trigger is false
        bash_script_index:
          type: string?
          default: |
            #!/bin/bash
            if [ "$0" = "true" ]
            then
              echo "Run: samtools index " ${@:1}
              samtools index "${@:1}"
            else
              echo "Skip samtools index " ${@:1}
            fi
          inputBinding:
            position: 20
          doc: |
            Bash function to run samtools index with all input parameters or skip it if trigger is false
        trigger:
          type: boolean?
          default: true
          doc: |
            If true - run samtools, if false - return sort_input and optional index file in secondaryFiles, previously staged
            into output directory.
        sort_compression_level:
          type: int?
          inputBinding:
            position: 11
            prefix: -l
          doc: |
            SORT: desired compression level for the final output file, ranging from 0 (uncompressed)
            or 1 (fastest but minimal compression) to 9 (best compression but slowest to write),
            similarly to gzip(1)'s compression level setting.
            If -l is not used, the default compression level will apply.
        sort_output_filename:
          type: string?
          inputBinding:
            position: 12
            prefix: -o
            valueFrom: |
              ${
                  if (self == "" || inputs.trigger == false){
                    return default_bam();
                  } else {
                    return self;
                  }
              }
          default: ""
          doc: |
            Write the final sorted output to FILE. Only out.bam|out.cram.
            If output file extension is set to SAM, tool will fail on the index step
        threads:
          type: int?
          doc: |
            Set number of sorting and compression threads [1] (Only for sorting)
        sort_input:
          type: File
          inputBinding:
            position: 16
          doc: |
            Input only in.sam|in.bam|in.cram. Optionally could be supplemented with index file in secondaryFiles
        csi_interval:
          type: int?
          inputBinding:
            position: 24
            prefix: -m
          doc: |
            Set minimum interval size for CSI indices to 2^INT [14]
        csi:
          type: boolean?
          doc: |
            Generate CSI-format index for BAM files. If input isn't cram.
        bai:
          type: boolean?
          doc: |
            Generate BAI-format index for BAM files [default]. If input isn't cram.
      outputs:
        bam_bai_pair:
          type: File
          outputBinding:
            glob: |
              ${
                  if (inputs.sort_output_filename == "" || inputs.trigger == false){
                    return default_bam();
                  } else {
                    return inputs.sort_output_filename;
                  }
              }
          secondaryFiles:
            ${
                if (inputs.trigger == true){
                  return self.basename + ext();
                } else {
                  return inputs.sort_input.secondaryFiles?inputs.sort_input.secondaryFiles:"null";
                }
            }
      baseCommand: [bash, '-c']
      arguments:
      #   run script sort position 5
        - valueFrom: |
            ${ return inputs.trigger ? "true" : "false" }
          position: 6
        # -l - position 11
        # -o sort_output_filename - position 12
        - valueFrom: bam
          position: 13
          prefix: -O
          # -n - position 14
        - valueFrom: $(inputs.threads?inputs.threads:1)
          position: 15
          prefix: -@
        # sort_input - position 16
        - valueFrom: ";"
          position: 17
          shellQuote: false
        - valueFrom: "bash"
          position: 18
        - valueFrom: "-c"
          position: 19
      #   run script index position 20
        - valueFrom: |
            ${ return inputs.trigger ? "true" : "false" }
          position: 21
        - valueFrom: $(inputs.bai?'-b':inputs.csi?'-c':[])
          position: 23
          # -m - position 24
        - valueFrom: $(inputs.threads?inputs.threads:1)
          position: 25
          prefix: -@
        - valueFrom: |
            ${
                if (inputs.sort_output_filename == "" || inputs.trigger == false){
                  return default_bam();
                } else {
                  return inputs.sort_output_filename;
                }
            }
          position: 26
        - valueFrom: |
            ${
                if (inputs.sort_output_filename == "" || inputs.trigger == false){
                  return default_bam() + ext();
                } else {
                  return inputs.sort_output_filename + ext();
                }
            }
          position: 27
    in:
      sort_input: align_reads/output
      threads: threads
    out: [bam_bai_pair]

  get_alignment_statistics:
    run:
      cwlVersion: v1.0
      class: CommandLineTool
      requirements:
      - class: InlineJavascriptRequirement
        expressionLib:
        - var default_output_filename = function() {
                if (inputs.output_filename == ""){
                  var root = inputs.bambai_pair.basename.split('.').slice(0,-1).join('.');
                  return (root == "")?inputs.bambai_pair.basename+".log":root+".log";
                } else {
                  return inputs.output_filename;
                }
              };
      hints:
      - class: DockerRequirement
        dockerPull: biowardrobe2/samtools:v1.4
      inputs:
        script:
          type: string?
          default: |
            #!/bin/bash
            samtools stats $0 | grep SN | cut -f 2-
          inputBinding:
            position: 4
          doc: "samtools stats with optional filtering criteria passes as $1"
        bambai_pair:
          type: File
          inputBinding:
            position: 5
          secondaryFiles: $(self.basename+".bai")  # due to bug in cwltool==1.0.20190621234233
          doc: "Coordinate sorted BAM alignment and index BAI files"
        output_filename:
          type: string?
          default: ""
          doc: "Output file name"
      outputs:
        log_file:
          type: File
          outputBinding:
            glob: $(default_output_filename())
          doc: "BAM file statistics"
        raw_total_sequences:
          type: int
          outputBinding:
            loadContents: true
            glob: $(default_output_filename())
            outputEval: |
              ${
                var s = self[0].contents.substring(self[0].contents.indexOf("raw total sequences"));
                return parseInt(s.substring(s.indexOf("raw total sequences")+21, s.indexOf("\n")));
              }
          doc: "Raw Total Sequences"
        reads_mapped:
          type: int
          outputBinding:
            loadContents: true
            glob: $(default_output_filename())
            outputEval: |
              ${
                var s = self[0].contents.substring(self[0].contents.indexOf("reads mapped"));
                return parseInt(s.substring(s.indexOf("reads mapped")+14, s.indexOf("\n")));
              }
          doc: "Reads Mapped"
        average_length:
          type: int
          outputBinding:
            loadContents: true
            glob: $(default_output_filename())
            outputEval: |
              ${
                var s = self[0].contents.substring(self[0].contents.indexOf("average length"));
                return parseInt(s.substring(s.indexOf("average length")+16, s.indexOf("\n")));
              }
          doc: "Reads Average Length"
      baseCommand: ["bash", "-c"]
      stdout: $(default_output_filename())
    in:
      bambai_pair: sort_and_index/bam_bai_pair
    out:
      - log_file
      - average_length
      - reads_mapped

  estimate_read_redundancy:
    run:
      cwlVersion: v1.0
      class: CommandLineTool
      requirements:
        - class: InlineJavascriptRequirement
          expressionLib:
          - var get_output_filename = function(input_file) {
                if (inputs.estimates_filename == "") {
                  var ext = "_preseq_estimates.tsv";
                  var root = input_file.basename.split('.').slice(0,-1).join('.');
                  return (root == "")?inputs.input_file.basename+ext:root+ext;
                } else {
                  return inputs.estimates_filename;
                }
            };
      hints:
        - class: DockerRequirement
          dockerPull: stevetsa/preseq:2.0
      inputs:
        confidence_level:
          type: float?
          inputBinding:
            position: 5
            prefix: "-cval"
          doc: "Level for confidence intervals, default: 0.95"
        extrapolation:
          type: float?
          inputBinding:
            position: 6
            prefix: "-extrap"
          doc: "Maximum extrapolation, default: 1e+10"
        max_fragment_size:
          type: int?
          inputBinding:
            position: 7
            prefix: "-seg_len"
          doc: "Maximum segment length when merging paired end bam reads, default: 5000"
        bootstraps:
          type: int?
          inputBinding:
            position: 8
            prefix: "-bootstraps"
          doc: "Number of bootstraps, default: 100"
        extrapolations_step:
          type: float?
          inputBinding:
            position: 9
            prefix: "-step"
          doc: "Step size in extrapolations, default: 1e+06"
        terms:
          type: int?
          inputBinding:
            position: 10
            prefix: "-terms"
          doc: "Maximum number of terms"
        defects_mode:
          type: boolean?
          inputBinding:
            position: 11
            prefix: "-defects"
          doc: "Defects mode to extrapolate without testing for defects"
        quick mode:
          type: boolean?
          inputBinding:
            position: 12
            prefix: "-quick"
          doc: "Quick mode, estimate yield without bootstrapping for confidence intervals"
        verbose_mode:
          type: boolean?
          inputBinding:
            position: 13
            prefix: "-verbose"
          doc: "Verbose mode"
        estimates_filename:
          type: string?
          inputBinding:
            position: 14
            prefix: "-output"
            valueFrom: $(get_output_filename(inputs.bam_file))
          default: ""
          doc: "Output filename"
        pe_mode:
          type: boolean?
          inputBinding:
            position: 15
            prefix: "-pe"
          doc: "Input is paired end read file"
        bam_file:
          type: File
          inputBinding:
            position: 16
          doc: "Coordinate sorted BAM file"
      outputs:
        estimates_file:
          type: File?
          outputBinding:
            glob: $(get_output_filename(inputs.bam_file))
      baseCommand: ["preseq", "lc_extrap", "-bam"]
      successCodes: [1]
    in:
      bam_file: sort_and_index/bam_bai_pair
      pe_mode:
        default: true
      extrapolation:
        default: 1000000000
    out: [estimates_file]


# -----------------------------------------------------------------------------------


  filter_reads:
    run:
      cwlVersion: v1.0
      class: CommandLineTool
      requirements:
      - class: InlineJavascriptRequirement
      hints:
      - class: DockerRequirement
        dockerPull: biowardrobe2/samtools:v1.4
      inputs:
        script:
          type: string?
          default: |
            #!/bin/bash
            echo "Filtering BAM file"
            echo "samtools idxstats $0 | cut -f 1 | grep -v -E \"`echo $1 | sed -e 's/ /$|/g'`$|\*\" | xargs samtools view -q $2 -o $3 $0"
            samtools idxstats $0 | cut -f 1 | grep -v -E "`echo $1 | sed -e 's/ /$|/g'`$|\*" | xargs samtools view -q $2 -o $3 $0
            echo "Sorting BAM file"
            echo "samtools sort $3 -o $3"
            samtools sort $3 -o $3
            echo "Indexing BAM file"
            echo "samtools index $3"
            samtools index $3
          inputBinding:
            position: 5
          doc: Script to exclude chromosomes from the BAM file and filter reads by quality
        bam_bai_pair:
          type: File
          inputBinding:
            position: 6
          secondaryFiles: $(self.basename+".bai")  # due to bug in cwltool==1.0.20190621234233
          doc: Indexed BAM+BAI files
        exclude_chromosome:
          type: string
          inputBinding:
            position: 7
          doc: "Space separated list of the chromosemes to exclude"
        quality:
          type: int?
          inputBinding:
            position: 8
          default: 0
          doc: "Skip alignments with MAPQ smaller than INT. Default 0"
        output_filename:
          type: string?
          inputBinding:
            position: 9
            valueFrom: |
              ${
                return (self == "")?inputs.bam_bai_pair.basename:self;
              }
          default: ""
          doc: "Output filename for the filtered BAM file"
      outputs:
        filtered_bam_bai_pair:
          type: File
          outputBinding:
            glob: "*.bam"
          secondaryFiles: ${return self.basename+".bai"}  # due to bug in cwltool==1.0.20190621234233
          doc: "Filtered BAM+BAI files"
      baseCommand: [bash, '-c']
    in:
      bam_bai_pair: sort_and_index/bam_bai_pair
      exclude_chromosome: exclude_chromosome
      quality:
        default: 30                 # how do we define 30 (range is from 0 to 255)
    out: [filtered_bam_bai_pair]
  
  remove_duplicates:
    run:
      cwlVersion: v1.0
      class: CommandLineTool
      requirements:
      - class: ShellCommandRequirement
      - class: InlineJavascriptRequirement
        expressionLib:
        - var default_output_filename = function() {
                return inputs.bam_file.location.split('/').slice(-1)[0];
              };
      - class: InitialWorkDirRequirement
        listing: |
          ${
            return  [
                      {
                        "entry": inputs.bam_file,
                        "entryname": "input_file_backup",
                        "writable": true
                      }
                    ]
          }
      hints:
      - class: DockerRequirement
        dockerPull: biowardrobe2/samtools:v1.4
      inputs:
        bash_script:
          type: string?
          default: |
            #!/bin/bash
            if [ "$0" = "true" ]
            then
              samtools rmdup "${@:1}"
            else
              echo "Skip samtools rmdup " ${@:1}
              mv ${@: -2}
            fi
          inputBinding:
            position: 1
          doc: |
            Bash function to run samtools rmdup with all input parameters or skip it if trigger is false
        trigger:
          type: boolean?
          default: true
          inputBinding:
            position: 2
            valueFrom: |
              ${ return self ? "true" : "false" }
          doc: |
            If true - run samtools rmdup, if false - return bam_file, previously staged into output directory and optional index file
            Use valueFrom to return string instead of boolean, because if return boolean False, argument is not printed
        single_end:
          type:
            - "null"
            - boolean
          inputBinding:
            position: 3
            prefix: '-s'
          doc: |
            rmdup for SE reads
        force_single_end:
          type:
            - "null"
            - boolean
          inputBinding:
            position: 4
            prefix: '-S'
          doc: |
            treat PE reads as SE in rmdup (force -s)
        bam_file:
          type: File
          inputBinding:
            position: 10
          doc: |
            Input sorted bam file (index file is optional)
        output_filename:
          type:
            - "null"
            - string
          inputBinding:
            position: 11
            valueFrom: |
              ${
                  if (self == "" || inputs.trigger == false){
                    return default_output_filename();
                  } else {
                    return self;
                  }
              }
          default: ""
          doc: |
            Writes the output bam file to output_filename if set,
            otherwise generates output_filename on the base of bam_file
      outputs:
        rmdup_output:
          type: File
          outputBinding:
            glob: |
              ${
                  if (inputs.output_filename == "" || inputs.trigger == false){
                    return default_output_filename();
                  } else {
                    return inputs.output_filename;
                  }
              }
          secondaryFiles: |
            ${
                if (inputs.bam_file.secondaryFiles && inputs.trigger == false){
                  return inputs.bam_file.secondaryFiles;
                } else {
                  return "null";
                }
              }
          doc: File with removed duplicates or bam_file with optional secondaryFiles
        rmdup_log:
          type: File
          outputBinding:
            glob: |
              ${
                if (inputs.output_filename == "" || inputs.trigger == false){
                  return default_output_filename().split('.').slice(0,-1).join('.') + '.rmdup';
                } else {
                  return inputs.output_filename.split('.').slice(0,-1).join('.') + '.rmdup';
                }
              }
      baseCommand: [bash, '-c']
      arguments:
        - valueFrom: |
            ${
              if (inputs.output_filename == "" || inputs.trigger == false){
                return " > " + default_output_filename().split('.').slice(0,-1).join('.') + ".rmdup 2>&1";
              } else {
                return " > " + inputs.output_filename.split('.').slice(0,-1).join('.') + ".rmdup 2>&1";
              }
            }
          position: 100000
          shellQuote: false
    in:
      bam_file: filter_reads/filtered_bam_bai_pair
    out: [rmdup_output]

  convert_bam_to_bed:
    run:
      cwlVersion: v1.0
      class: CommandLineTool
      requirements:
      - class: InlineJavascriptRequirement
        expressionLib:
        - var default_output_filename = function() {
                if (inputs.output_filename == ""){
                  var root = inputs.bam_file.basename.split('.').slice(0,-1).join('.');
                  return (root == "")?inputs.bam_file.basename+".bed":root+".bed";
                } else {
                  return inputs.output_filename;
                }
              };
      hints:
      - class: DockerRequirement
        dockerPull: biowardrobe2/bedtools2:v2.26.0
      inputs:
        bam_file:
          type: File
          inputBinding:
            position: 5
            prefix: "-i"
          doc: "Input BAM file (not necessary sorted or indexed)"
        output_filename:
          type: string?
          default: ""
          doc: "Output BED filename"
      outputs:
        bed_file:
          type: File
          outputBinding:
            glob: $(default_output_filename())
          doc: "Sequences file"
      baseCommand: ["bedtools", "bamtobed"]
      stdout: $(default_output_filename())
    in:
      bam_file: remove_duplicates/rmdup_output   # do we need to split reads by N
    out: [bed_file]

  shift_reads:
    run:
      cwlVersion: v1.0
      class: CommandLineTool
      hints:
      - class: DockerRequirement
        dockerPull: biowardrobe2/scidap:v0.0.3
      inputs:
        script:
          type: string?
          default: |
            cat "$0" | grep "$1" | sed "s/$1//g"  > `basename $0`
          inputBinding:
            position: 1
        input_file:
          type:
            - File
            - File[]
          inputBinding:
            position: 2
        param:
          type:
          - string?
          - string[]
          inputBinding:
            position: 3
      outputs:
        output_file:
          type: File
          outputBinding:
            glob: "*"
      baseCommand: [bash, '-c']
    in:
      input_file: convert_bam_to_bed/bed_file
      script:
        default: cat "$0" | awk 'BEGIN {OFS = "\t"}; {if ($6 == "+") print $1,$2+4,$3+4,$4,$5,$6; else print $1,$2-5,$3-5,$4,$5,$6}' > `basename $0`
    out: [output_file]

  remove_blacklisted:
    run:
      cwlVersion: v1.0
      class: CommandLineTool
      requirements:
      - class: InlineJavascriptRequirement
        expressionLib:
        - var default_output_filename = function() {
                if (inputs.output_filename == ""){
                  return inputs.file_a.basename;
                } else {
                  return inputs.output_filename;
                }
              };
      hints:
      - class: DockerRequirement
        dockerPull: biowardrobe2/bedtools2:v2.26.0
      inputs:
        file_a:
          type: File
          inputBinding:
            position: 5
            prefix: "-a"
          doc: "BAM/BED/GFF/VCF file A. Each feature in A is compared to B in search of overlaps"
        file_b:
          type: File
          inputBinding:
            position: 6
            prefix: "-b"
          doc: "BAM/BED/GFF/VCF file B. Each feature in A is compared to B in search of overlaps"
        count:
          type: boolean?
          inputBinding:
            position: 7
            prefix: "-c"
          doc: "For each entry in A, report the number of hits in B. Reports 0 for A entries that have no overlap with B" 
        no_overlaps:
          type: boolean?
          inputBinding:
            position: 8
            prefix: "-v"
          doc: "Only report those entries in A that have _no overlaps_ with B" 
        output_filename:
          type: string?
          default: ""
          doc: "Output file name"
      outputs:
        intersected_file:
          type: File
          outputBinding:
            glob: $(default_output_filename())
          doc: "Intersected BED file"
      baseCommand: ["bedtools", "intersect"]
      stdout: $(default_output_filename())
    in:
      file_a: shift_reads/output_file
      file_b: blacklisted_regions_bed
      no_overlaps:
        default: true
    out: [intersected_file]
                

# -----------------------------------------------------------------------------------


  group_by_chromosome:
    run:
      cwlVersion: v1.0
      class: CommandLineTool
      requirements:
        - class: InlineJavascriptRequirement
          expressionLib:
          - var get_output_filename = function() {
                if (inputs.output_filename) {
                  return inputs.output_filename;
                }
                return inputs.unsorted_file.location.split('/').slice(-1)[0];
            };
      hints:
      - class: DockerRequirement
        dockerPull: biowardrobe2/scidap:v0.0.2
      inputs:
        unsorted_file:
          type: File
          inputBinding:
            position: 4
        key:
          type:
            type: array
            items: string
            inputBinding:
              prefix: "-k"
          inputBinding:
            position: 1
          doc: |
            -k, --key=POS1[,POS2]
            start a key at POS1, end it at POS2 (origin 1)
        output_filename:
          type: string?
          doc: |
            Name for generated output file
      outputs:
        sorted_file:
          type: stdout
      stdout: $(get_output_filename())
      baseCommand: ["sort"]
    in:
      unsorted_file: remove_blacklisted/intersected_file
      key:
        default: ["1,1"]
    out: [sorted_file]

  get_genome_coverage:
    run:
      cwlVersion: v1.0
      class: CommandLineTool
      requirements:
      - class: InlineJavascriptRequirement
        expressionLib:
        - var default_output_filename = function() {
                var ext = (inputs.depth == "-bg" || inputs.depth == "-bga")?".bedGraph":".tab";
                return inputs.input_file.location.split('/').slice(-1)[0].split('.').slice(0,-1).join('.') + ext;
              };
      hints:
      - class: DockerRequirement
        dockerPull: biowardrobe2/bedtools2:v2.26.0
      inputs:
        input_file:
          type: File
          inputBinding:
            position: 16
            valueFrom: |
                ${
                  var prefix = ((/.*\.bam$/i).test(inputs.input_file.path))?'-ibam':'-i';
                  return [prefix, inputs.input_file.path];
                }
          doc: |
            The input file can be in BAM format (Note: BAM must be sorted by position) or <bed/gff/vcf>.
            Prefix is selected on the base of input file extension
        chrom_length_file:
          type:
          - "null"
          - File
          inputBinding:
            position: 17
            prefix: "-g"
          doc: |
            Input genome file. Needed only when -i flag. The genome file is tab delimited <chromName><TAB><chromSize>
        depth:
          type:
          - "null"
          - type: enum
            name: "depth"
            symbols: ["-bg","-bga","-d", "-dz"]
          inputBinding:
            position: 5
          doc: |
            Report the depth type. By default, bedtools genomecov will compute a histogram of coverage
            for the genome file provided (intputs.chrom_length_file)
        scale:
          type:
          - "null"
          - float
          inputBinding:
            position: 6
            prefix: -scale
          doc: |
            Scale the coverage by a constant factor.
            Each coverage value is multiplied by this factor before being reported.
            Useful for normalizing coverage by, e.g., reads per million (RPM).
            - Default is 1.0; i.e., unscaled.
            - (FLOAT)
        mapped_reads_number:
          type:
          - "null"
          - int
          inputBinding:
            position: 7
            prefix: -scale
            valueFrom: |
              ${
                if (inputs.scale){
                  return null;
                } else if (inputs.mapped_reads_number) {
                  return 1000000/inputs.mapped_reads_number;
                } else {
                  return null;
                }
              }
          doc: |
            Optional parameter to calculate scale as 1000000/mapped_reads_number if inputs.scale is not provided
        split:
          type:
          - "null"
          - boolean
          inputBinding:
            position: 8
            prefix: "-split"
          doc: |
            treat "split" BAM or BED12 entries as distinct BED intervals.
            when computing coverage.
            For BAM files, this uses the CIGAR "N" and "D" operations
            to infer the blocks for computing coverage.
            For BED12 files, this uses the BlockCount, BlockStarts, and BlockEnds
            fields (i.e., columns 10,11,12).
        strand:
          type:
          - "null"
          - string
          inputBinding:
            position: 9
            prefix: "-strand"
          doc: |
            Calculate coverage of intervals from a specific strand.
            With BED files, requires at least 6 columns (strand is column 6).
            - (STRING): can be + or -
        pairchip:
          type:
          - "null"
          - boolean
          inputBinding:
            position: 10
            prefix: "-pc"
          doc: |
            pair-end chip seq experiment
        du:
          type:
          - "null"
          - boolean
          inputBinding:
            position: 11
            prefix: "-du"
          doc: |
            Change strand af the mate read (so both reads from the same strand) useful for strand specific.
            Works for BAM files only
        fragment_size:
          type:
          - "null"
          - int
          inputBinding:
            position: 12
            prefix: "-fs"
          doc: |
            Set fixed fragment size
        max:
          type:
          - "null"
          - int
          inputBinding:
            position: 13
            prefix: "-max"
          doc: |
            Combine all positions with a depth >= max into
            a single bin in the histogram. Irrelevant
            for -d and -bedGraph
            - (INTEGER)
        m5:
          type:
          - "null"
          - boolean
          inputBinding:
            position: 14
            prefix: "-5"
          doc: |
            Calculate coverage of 5" positions (instead of entire interval)
        m3:
          type:
          - "null"
          - boolean
          inputBinding:
            position: 15
            prefix: "-3"
          doc: |
            Calculate coverage of 3" positions (instead of entire interval)
        output_filename:
          type:
          - "null"
          - string
          doc: |
            Name for generated output file
      outputs:
        genome_coverage_file:
          type: File
          outputBinding:
            glob: |
              ${
                if (inputs.output_filename == null){
                  return default_output_filename();
                } else {
                  return inputs.output_filename;
                }
              }
          doc: |
            Generated genome coverage output file
      stdout: |
        ${
          if (inputs.output_filename == null){
            return default_output_filename();
          } else {
            return inputs.output_filename;
          }
        }
      baseCommand: ["bedtools", "genomecov"]
    in:
      input_file: group_by_chromosome/sorted_file
      chrom_length_file: chrom_length_file
      depth:
        default: "-bg"
      mapped_reads_number: get_alignment_statistics/reads_mapped
    out: [genome_coverage_file]

  sort_genome_coverage:
    run:
      cwlVersion: v1.0
      class: CommandLineTool
      requirements:
        - class: InlineJavascriptRequirement
          expressionLib:
          - var get_output_filename = function() {
                if (inputs.output_filename) {
                  return inputs.output_filename;
                }
                return inputs.unsorted_file.location.split('/').slice(-1)[0];
            };
      hints:
      - class: DockerRequirement
        dockerPull: biowardrobe2/scidap:v0.0.2
      inputs:
        unsorted_file:
          type: File
          inputBinding:
            position: 4
        key:
          type:
            type: array
            items: string
            inputBinding:
              prefix: "-k"
          inputBinding:
            position: 1
          doc: |
            -k, --key=POS1[,POS2]
            start a key at POS1, end it at POS2 (origin 1)
        output_filename:
          type: string?
          doc: |
            Name for generated output file
      outputs:
        sorted_file:
          type: stdout
      stdout: $(get_output_filename())
      baseCommand: ["sort"]
    in:
      unsorted_file: get_genome_coverage/genome_coverage_file
      key:
        default: ["1,1","2,2n"]
    out: [sorted_file]

  convert_genome_coverage_to_bigwig:
    run:
      cwlVersion: v1.0
      class: CommandLineTool
      requirements:
      - class: InlineJavascriptRequirement
        expressionLib:
        - var default_output_filename = function() {
                var basename = inputs.bedgraph_file.location.split('/').slice(-1)[0];
                var root = basename.split('.').slice(0,-1).join('.');
                var ext = ".bigWig";
                return (root == "")?basename+ext:root+ext;
              };
      hints:
      - class: DockerRequirement
        dockerPull: biowardrobe2/ucscuserapps:v358
      inputs:
        bedgraph_file:
          type: File
          inputBinding:
            position: 10
          doc: |
            Four column bedGraph file: <chrom> <start> <end> <value>
        chrom_length_file:
          type: File
          inputBinding:
            position: 11
          doc: |
            Two-column chromosome length file: <chromosome name> <size in bases>
        unc:
          type:
            - "null"
            - boolean
          inputBinding:
            position: 5
            prefix: "-unc"
          doc: |
            Disable compression
        items_per_slot:
          type:
            - "null"
            - int
          inputBinding:
            separate: false
            position: 6
            prefix: "-itemsPerSlot="
          doc: |
            Number of data points bundled at lowest level. Default 1024
        block_size:
          type:
            - "null"
            - int
          inputBinding:
            separate: false
            position: 7
            prefix: "-blockSize="
          doc: |
            Number of items to bundle in r-tree.  Default 256
        output_filename:
          type:
            - "null"
            - string
          inputBinding:
            position: 12
            valueFrom: |
              ${
                  if (self == ""){
                    return default_output_filename();
                  } else {
                    return self;
                  }
              }
          default: ""
          doc: |
            If set, writes the output bigWig file to output_filename,
            otherwise generates filename from default_output_filename()
      outputs:
        bigwig_file:
          type: File
          outputBinding:
            glob: |
              ${
                  if (inputs.output_filename == ""){
                    return default_output_filename();
                  } else {
                    return inputs.output_filename;
                  }
              }
      baseCommand: ["bedGraphToBigWig"]
    in:
      bedgraph_file: sort_genome_coverage/sorted_file
      chrom_length_file: chrom_length_file
    out: [bigwig_file]


# -----------------------------------------------------------------------------------


  call_peaks:
    run:
      cwlVersion: v1.0
      class: CommandLineTool
      requirements:
      - class: ShellCommandRequirement
      - class: InlineJavascriptRequirement
        expressionLib:
        - var default_name = function(input_staged, sufix) {
            input_staged = input_staged || false;
            sufix = sufix || "_macs";
            if (inputs.trigger == false && input_staged){
              return input_staged.basename;
            } else {
              if (Object.prototype.toString.call(inputs.treatment_file) === '[object Array]'){
                return inputs.treatment_file[0].location.split('/').slice(-1)[0].split('.').slice(0,-1).join('.')+sufix;
              } else {
                return inputs.treatment_file.location.split('/').slice(-1)[0].split('.').slice(0,-1).join('.')+sufix;
              }
            }
          }
      - class: InitialWorkDirRequirement
        listing: |
          ${
            var listing = []
            if (inputs.peak_xls_file_staged){
              listing.push(
                {
                  "entry": inputs.peak_xls_file_staged,
                  "entryname": inputs.peak_xls_file_staged.basename,
                  "writable": true
                }
              )
            }
            if (inputs.narrow_peak_file_staged){
              listing.push(
                {
                  "entry": inputs.narrow_peak_file_staged,
                  "entryname": inputs.narrow_peak_file_staged.basename,
                  "writable": true
                }
              )
            }
            if (inputs.broad_peak_file_staged){
              listing.push(
                {
                  "entry": inputs.broad_peak_file_staged,
                  "entryname": inputs.broad_peak_file_staged.basename,
                  "writable": true
                }
              )
            }
            if (inputs.gapped_peak_file_staged){
              listing.push(
                {
                  "entry": inputs.gapped_peak_file_staged,
                  "entryname": inputs.gapped_peak_file_staged.basename,
                  "writable": true
                }
              )
            }
            if (inputs.peak_summits_file_staged){
              listing.push(
                {
                  "entry": inputs.peak_summits_file_staged,
                  "entryname": inputs.peak_summits_file_staged.basename,
                  "writable": true
                }
              )
            }
            if (inputs.moder_r_file_staged){
              listing.push(
                {
                  "entry": inputs.moder_r_file_staged,
                  "entryname": inputs.moder_r_file_staged.basename,
                  "writable": true
                }
              )
            }
            if (inputs.treat_pileup_bdg_file_staged){
              listing.push(
                {
                  "entry": inputs.treat_pileup_bdg_file_staged,
                  "entryname": inputs.treat_pileup_bdg_file_staged.basename,
                  "writable": true
                }
              )
            }
            if (inputs.control_lambda_bdg_file_staged){
              listing.push(
                {
                  "entry": inputs.control_lambda_bdg_file_staged,
                  "entryname": inputs.control_lambda_bdg_file_staged.basename,
                  "writable": true
                }
              )
            }
            if (inputs.macs_log_staged){
              listing.push(
                {
                  "entry": inputs.macs_log_staged,
                  "entryname": inputs.macs_log_staged.basename,
                  "writable": true
                }
              )
            }
            return listing;
          }
      hints:
      - class: DockerRequirement
        dockerPull: biowardrobe2/macs2:v2.1.1
        dockerFile: >
          $import: ./dockerfiles/macs2-Dockerfile
      inputs:
        script:
          type: string?
          default: |
            #!/bin/bash
            if [ "$0" = "true" ]
            then
              ls | grep -v ${@: -1}.log | xargs rm -f
              macs2 callpeak "${@:1}"
            else
              echo "Skip macs2 callpeak " ${@:1}
            fi
          inputBinding:
            position: 1
          doc: |
            Bash function to run MACS2 callpeak with all input parameters or skip it if trigger is false
        trigger:
          type: boolean?
          default: true
          inputBinding:
            position: 2
            valueFrom: |
              ${return self?"true":"false"}
          doc: |
            If true - run MACS2, if false - return staged files
        peak_xls_file_staged:
          type: File?
          doc: For staging in a case of trigger is set to false
        narrow_peak_file_staged:
          type: File?
          doc: For staging in a case of trigger is set to false
        broad_peak_file_staged:
          type: File?
          doc: For staging in a case of trigger is set to false
        gapped_peak_file_staged:
          type: File?
          doc: For staging in a case of trigger is set to false
        peak_summits_file_staged:
          type: File?
          doc: For staging in a case of trigger is set to false
        moder_r_file_staged:
          type: File?
          doc: For staging in a case of trigger is set to false
        treat_pileup_bdg_file_staged:
          type: File?
          doc: For staging in a case of trigger is set to false
        control_lambda_bdg_file_staged:
          type: File?
          doc: For staging in a case of trigger is set to false
        macs_log_staged:
          type: File?
          doc: For staging in a case of trigger is set to false
        treatment_file:
          type:
            - File
            - type: array
              items: File
          inputBinding:
            position: 10
            prefix: -t
          doc: |
            This is the only REQUIRED parameter for MACS. File can be in any supported format specified by –format option.
            Check –format for detail. If you have more than one alignment files, you can specify them as `-t A B C`.
            MACS will pool up all these files together.
        name:
          type:
            - "null"
            - string
          inputBinding:
            position: 999
            prefix: -n
            valueFrom: |
              ${
                  if (self == "" || inputs.trigger == false){
                    return default_name();
                  } else {
                    return self;
                  }
              }
          default: ""
          doc: |
            The name string of the experiment. MACS will use this string NAME to create output files like ‘NAME_peaks.xls’,
            ‘NAME_negative_peaks.xls’, ‘NAME_peaks.bed’ , ‘NAME_summits.bed’, ‘NAME_model.r’ and so on.
            So please avoid any confliction between these filenames and your existing files.
            DEFAULT: generated on the base of the treatment input
        control:
          type:
            - "null"
            - File
            - type: array
              items: File
          inputBinding:
            position: 12
            prefix: -c
          doc: |
            The control or mock data file. Please follow the same direction as for -t/–treatment.
        format_mode:
          type:
            - "null"
            - string
          inputBinding:
            position: 13
            prefix: -f
          doc: |
            {AUTO,BAM,SAM,BED,ELAND,ELANDMULTI,ELANDEXPORT,BOWTIE,BAMPE}, --format
            {AUTO,BAM,SAM,BED,ELAND,ELANDMULTI,ELANDEXPORT,BOWTIE,BAMPE} Format of tag file,
            "AUTO", "BED" or "ELAND" or "ELANDMULTI" or "ELANDEXPORT" or "SAM" or "BAM"
            or "BOWTIE" or "BAMPE". The default AUTO option will var MACS decide which format
            the file is. Note that MACS can''t detect "BAMPE" or "BEDPE" format with "AUTO",
            and you have to implicitly specify the format for "BAMPE" and "BEDPE".
            DEFAULT: AUTO
        genome_size:
          type:
            - "null"
            - string
          inputBinding:
            position: 14
            prefix: -g
          doc: |
            It’s the mappable genome size or effective genome size which is defined as the genome size which can be sequenced.
            Because of the repetitive features on the chromsomes, the actual mappable genome size will be smaller than the
            original size, about 90% or 70% of the genome size. The default hs – 2.7e9 is recommended for UCSC human hg18
            assembly. Here are all precompiled parameters for effective genome size:
              hs:	2.7e9
              mm:	1.87e9
              ce:	9e7
              dm:	1.2e8
            DEFAULT: hs
        keep_dup:
          type:
            - "null"
            - string
          inputBinding:
            position: 15
            prefix: --keep-dup
          doc: |
            It controls the MACS behavior towards duplicate tags
            at the exact same location -- the same coordination
            and the same strand. The 'auto' option makes MACS
            calculate the maximum tags at the exact same location
            based on binomal distribution using 1e-5 as pvalue
            cutoff; and the 'all' option keeps every tags. If an
            integer is given, at most this number of tags will be
            kept at the same location. The default is to keep one
            tag at the same location.
            DEFAULT: 1
        buffer_size:
          type:
            - "null"
            - int
          inputBinding:
            position: 16
            prefix: --buffer-size
          doc: |
            Buffer size for incrementally increasing internal
            array size to store reads alignment information. In
            most cases, you don't have to change this parameter.
            However, if there are large number of
            chromosomes/contigs/scaffolds in your alignment, it's
            recommended to specify a smaller buffer size in order
            to decrease memory usage (but it will take longer time
            to read alignment files). Minimum memory requested for
            reading an alignment file is about # of CHROMOSOME *
            BUFFER_SIZE * 2 Bytes.
            DEFAULT: 100000
        bdg:
          type:
            - "null"
            - boolean
          inputBinding:
            position: 17
            prefix: --bdg
          doc: |
            If this flag is on, MACS will store the fragment pileup, control lambda, -log10pvalue and -log10qvalue scores in bedGraph files.
            The bedGraph files will be stored in current directory named NAME+’_treat_pileup.bdg’ for treatment data, NAME+’_control_lambda.bdg’
            for local lambda values from control, NAME+’_treat_pvalue.bdg’ for Poisson pvalue scores (in -log10(pvalue) form),
            and NAME+’_treat_qvalue.bdg’ for q-value scores from
            Benjamini–Hochberg–Yekutieli procedure <http://en.wikipedia.org/wiki/False_discovery_rate#Dependent_tests>
            DEFAULT: False
        trackline:
          type:
            - "null"
            - boolean
          inputBinding:
            position: 18
            prefix: --trackline
          doc: |
            Tells MACS to include trackline with bedGraph files. To include this trackline
            while displaying bedGraph at UCSC genome browser, can show name and description
            of the file as well. Require -B to be set.
            DEFAULT: False
        spmr:
          type:
            - "null"
            - boolean
          inputBinding:
            position: 19
            prefix: --SPMR
          doc: |
            If True, MACS will save signal per million reads for fragment pileup profiles.
            Require --bdg to be set.
            DEFAULT: False
        tsize:
          type:
            - "null"
            - int
          inputBinding:
            position: 20
            prefix: --tsize
          doc: |
            Tag size. This will overide the auto detected tag size.
            DEFAULT: False
        bw:
          type:
            - "null"
            - int
          inputBinding:
            position: 21
            prefix: --bw
          doc: |
            Band width for picking regions to compute  fragment  size.  This
            value is only used while building the shifting model
            DEFAULT: 300
        mfold:
          type:
            - "null"
            - string
          inputBinding:
            position: 22
            prefix: -m
            valueFrom: |
              ${
                return self.replace(/\s+/g, ' ').split(' ');
              }
          doc: |
            Select the regions within MFOLD range of high-
            confidence enrichment ratio against background to
            build model. Fold-enrichment in regions must be lower
            than upper limit, and higher than the lower limit. Use
            as "-m 10 30"
            DEFAULT: 5 50
        fix_bimodal:
          type:
            - "null"
            - boolean
          inputBinding:
            position: 23
            prefix: --fix-bimodal
          doc: |
            Whether turn on the auto pair model process. If set, when MACS failed to
            build paired model, it will use the nomodel settings, the --exsize parameter
            to extend each tags towards 3'' direction. Not to use this automate fixation
            is a default behavior now.
            DEFAULT: False
        nomodel:
          type:
            - "null"
            - boolean
          inputBinding:
            position: 24
            prefix: --nomodel
          doc: |
            Whether or not to build the shifting model. If True,  MACS will not build
            model. by default it means  shifting size = 100, try to set extsize to change it.
            DEFAULT: False
        shift:
          type:
            - "null"
            - int
          inputBinding:
            position: 25
            prefix: --shift
          doc: |
            (NOT the legacy --shiftsize option!) The arbitrary shift in bp. Use discretion
            while setting it other than default value. When NOMODEL is set, MACS will use
            this value to move cutting ends (5'') towards 5''->3'' direction then apply
            EXTSIZE to extend them to fragments. When this value is negative, ends will
            be moved toward 3''->5'' direction. Recommended to keep it as default 0 for
            ChIP-Seq datasets, or -1 * half of EXTSIZE together with EXTSIZE option for
            detecting enriched cutting loci such as certain DNAseI-Seq datasets. Note, you
            can''t set values other than 0 if format is BAMPE for paired-end data.
            DEFAULT: 0
        extsize:
          type:
            - "null"
            - int
          inputBinding:
            position: 26
            prefix: --extsize
          doc: |
            The arbitrary extension size in bp. When nomodel is  true, MACS will use
            this value as fragment size to  extend each read towards 3'' end, then pile
            them up.  It''s exactly twice the number of obsovare SHIFTSIZE.  In previous
            language, each read is moved 5''->3''  direction to middle of fragment by 1/2
            d, then  extended to both direction with 1/2 d. This is  equivalent to say each
            read is extended towards 5''->3''  into a d size fragment.EXTSIZE
            and  SHIFT can be combined when necessary. Check SHIFT  option.
            DEFAULT: 200
        q_value:
          type:
            - "null"
            - float
          inputBinding:
            position: 27
            prefix: -q
          doc: |
            Minimum FDR (q-value) cutoff for peak detection. -q, and
            -p are mutually exclusive.
            DEFAULT: 0.05
        p_value:
          type:
            - "null"
            - float
          inputBinding:
            position: 28
            prefix: -p
          doc: |
            Pvalue cutoff for peak detection. DEFAULT: not set.  -q, and -p are mutually
            exclusive. If pvalue cutoff is set, qvalue will not be calculated and reported
            as -1  in the final .xls file.
            DEFAULT: null
        to_large:
          type:
            - "null"
            - boolean
          inputBinding:
            position: 29
            prefix: --to-large
          doc: |
            When set, scale the small sample up to the bigger sample. By default, the
            bigger dataset will be scaled down towards the smaller dataset, which will lead
            to smaller p/qvalues and more specific results. Keep in mind that scaling down
            will bring down background noise more.
            DEFAULT: False
        ratio:
          type:
            - "null"
            - float
          inputBinding:
            position: 30
            prefix: --ratio
          doc: |
            When set, use a custom scaling ratio of ChIP/control
            (e.g. calculated using NCIS) for linear scaling.
            DEFAULT: null
        down_sample:
          type:
            - "null"
            - boolean
          inputBinding:
            position: 31
            prefix: --down-sample
          doc: |
            When set, random sampling method will scale down the bigger sample. By default,
            MACS uses linear scaling. Warning: This option will make your result unstable
            and irreproducible since each time, random reads would be selected. Consider
            to use ''randsample'' script instead. <not implmented>If used together with
            --SPMR, 1 million unique reads will be randomly picked.</not implemented> Caution:
            due to the implementation, the final number of selected reads may not be as
            you expected!
            DEFAULT: False
        seed:
          type:
            - "null"
            - int
          inputBinding:
            position: 32
            prefix: --seed
          doc: |
            Set the random seed while down sampling data. Must be
            a non-negative integer in order to be effective.
            DEFAULT: null
        nolambda:
          type:
            - "null"
            - boolean
          inputBinding:
            position: 33
            prefix: --nolambda
          doc: |
            If True, MACS will use fixed background lambda as local lambda for every
            peak region. Normally, MACS calculates a dynamic local lambda to reflect the
            local bias due to potential chromatin structure.
            DEFAULT: False
        slocal:
          type:
            - "null"
            - int
          inputBinding:
            position: 34
            prefix: --slocal
          doc: |
            The small nearby region in basepairs to calculate
            dynamic lambda. This is used to capture the bias near
            the peak summit region. Invalid if there is no control
            data. If you set this to 0, MACS will skip slocal
            lambda calculation. *Note* that MACS will always
            perform a d-size local lambda calculation. The final
            local bias should be the maximum of the lambda value
            from d, slocal, and llocal size windows.
            DEFAULT: 1000
        llocal:
          type:
            - "null"
            - int
          inputBinding:
            position: 35
            prefix: --llocal
          doc: |
            The large nearby region in basepairs to calculate
            dynamic lambda. This is used to capture the surround
            bias. If you set this to 0, MACS will skip llocal
            lambda calculation. *Note* that MACS will always
            perform a d-size local lambda calculation. The final
            local bias should be the maximum of the lambda value
            from d, slocal, and llocal size windows.
            DEFAULT: 10000.
        broad:
          type:
            - "null"
            - boolean
          inputBinding:
            position: 36
            prefix: --broad
          doc: |
            If set, MACS will try to call broad peaks by linking nearby highly enriched
            regions. The linking region is controlled by another cutoff through --linking-cutoff.
            The maximum linking region length is 4 times of d from MACS.
            DEFAULT: False
        broad_cutoff:
          type:
            - "null"
            - boolean
          inputBinding:
            position: 37
            prefix: --broad-cutoff
          doc: |
            Cutoff for broad region. This option is not available
            unless --broad is set. If -p is set, this is a pvalue
            cutoff, otherwise, it's a qvalue cutoff.
            DEFAULT: 0.1
        cutoff_analysis:
          type:
            - "null"
            - boolean
          inputBinding:
            position: 38
            prefix: --cutoff-analysis
          doc: |
            While set, MACS2 will analyze number or total length of peaks that can be
            called by different p-value cutoff then output a summary table to help user
            decide a better cutoff. The table will be saved in NAME_cutoff_analysis.txt
            file. Note, minlen and maxgap may affect the results. WARNING: May take ~30
            folds longer time to finish.
            DEFAULT: False
        call_summits:
          type:
            - "null"
            - boolean
          inputBinding:
            position: 39
            prefix: --call-summits
          doc: |
            If set, MACS will use a more sophisticated signal processing approach to
            find subpeak summits in each enriched peak region.
            DEFAULT: False
        fe_cutoff:
          type:
            - "null"
            - float
          inputBinding:
            position: 40
            prefix: --fe-cutoff
          doc: |
            When set, the value will be used to filter out peaks
            with low fold-enrichment. Note, MACS2 use 1.0 as
            pseudocount while calculating fold-enrichment.
            DEFAULT: 1.0
        verbose:
          type:
            - "null"
            - int
          inputBinding:
            position: 41
            prefix: --verbose
          doc: |
            Log level
      outputs:
        peak_xls_file:
          type: File?
          outputBinding:
            glob:
              ${
                  if (inputs.name == "" || inputs.trigger == false){
                    return default_name(inputs.peak_xls_file_staged, '_macs_peaks.xls');
                  } else {
                    return inputs.name + '_peaks.xls';
                  }
              }
        narrow_peak_file:
          type: File?
          outputBinding:
            glob:
              ${
                  if (inputs.name == "" || inputs.trigger == false){
                    return default_name(inputs.narrow_peak_file_staged, '_macs_peaks.narrowPeak');
                  } else {
                    return inputs.name + '_peaks.narrowPeak';
                  }
              }
        broad_peak_file:
          type: File?
          outputBinding:
            glob:
              ${
                  if (inputs.name == "" || inputs.trigger == false){
                    return default_name(inputs.broad_peak_file_staged, '_macs_peaks.broadPeak');
                  } else {
                    return inputs.name + '_peaks.broadPeak';
                  }
              }
        gapped_peak_file:
          type: File?
          outputBinding:
            glob:
              ${
                  if (inputs.name == "" || inputs.trigger == false){
                    return default_name(inputs.gapped_peak_file_staged, '_macs_peaks.gappedPeak');
                  } else {
                    return inputs.name + '_peaks.gappedPeak';
                  }
              }
        peak_summits_file:
          type: File?
          outputBinding:
            glob:
              ${
                  if (inputs.name == "" || inputs.trigger == false){
                    return default_name(inputs.peak_summits_file_staged, '_macs_summits.bed');
                  } else {
                    return inputs.name + '_summits.bed';
                  }
              }
        moder_r_file:
          type: File?
          outputBinding:
            glob:
              ${
                  if (inputs.name == "" || inputs.trigger == false){
                    return default_name(inputs.moder_r_file_staged, '_macs_model.r');
                  } else {
                    return inputs.name + '_model.r';
                  }
              }
        treat_pileup_bdg_file:
          type: File?
          outputBinding:
            glob:
              ${
                  if (inputs.name == "" || inputs.trigger == false){
                    return default_name(inputs.treat_pileup_bdg_file_staged, '_macs_treat_pileup.bdg');
                  } else {
                    return inputs.name + '_treat_pileup.bdg';
                  }
              }
        control_lambda_bdg_file:
          type: File?
          outputBinding:
            glob:
              ${
                  if (inputs.name == "" || inputs.trigger == false){
                    return default_name(inputs.control_lambda_bdg_file_staged, '_macs_control_lambda.bdg');
                  } else {
                    return inputs.name + '_control_lambda.bdg';
                  }
              }
        macs_log:
          type: File?
          outputBinding:
            glob: |
              ${
                  if (inputs.name == "" || inputs.trigger == false){
                    return default_name(null, '_macs.log');
                  } else {
                    return inputs.name + '.log';
                  }
              }
      baseCommand: [bash, '-c']
      arguments:
        - valueFrom:
            ${
                if (inputs.name == "" || inputs.trigger == false ){
                  return ' 2>> ' + default_name(null, '_macs.log');
                } else {
                  return ' 2>> ' + inputs.name + '.log';
                }
            }
          position: 100000
          shellQuote: false
    in:
      treatment_file: remove_blacklisted/intersected_file
      format_mode:
        default: "BED"
      genome_size: genome_size
      keep_dup:
        default: "all"
      nomodel:
        default: true
      shift:
        source: get_alignment_statistics/average_length
        valueFrom: $(-Math.round(self/2))
      extsize: get_alignment_statistics/average_length
    out:
      - narrow_peak_file
      - macs_log

  sort_peaks:
    run:
      cwlVersion: v1.0
      class: CommandLineTool
      requirements:
        - class: InlineJavascriptRequirement
          expressionLib:
          - var get_output_filename = function() {
                if (inputs.output_filename) {
                  return inputs.output_filename;
                }
                return inputs.unsorted_file.location.split('/').slice(-1)[0];
            };
      hints:
      - class: DockerRequirement
        dockerPull: biowardrobe2/scidap:v0.0.2
      inputs:
        unsorted_file:
          type: File
          inputBinding:
            position: 4
        key:
          type:
            type: array
            items: string
            inputBinding:
              prefix: "-k"
          inputBinding:
            position: 1
          doc: |
            -k, --key=POS1[,POS2]
            start a key at POS1, end it at POS2 (origin 1)
        output_filename:
          type: string?
          doc: |
            Name for generated output file
      outputs:
        sorted_file:
          type: stdout
      stdout: $(get_output_filename())
      baseCommand: ["sort"]
    in:
      unsorted_file: call_peaks/narrow_peak_file
      key:
        default: ["1,1","2,2n"]
    out: [sorted_file]

  merge_peaks:
    run:
      cwlVersion: v1.0
      class: CommandLineTool
      requirements:
      - class: InlineJavascriptRequirement
        expressionLib:
        - var default_output_filename = function() {
                if (inputs.output_filename == ""){
                  return inputs.bed_file.basename;
                } else {
                  return inputs.output_filename;
                }
              };
      hints:
      - class: DockerRequirement
        dockerPull: biowardrobe2/bedtools2:v2.26.0
      inputs:
        bed_file:
          type: File
          inputBinding:
            position: 5
            prefix: "-i"
          doc: "The input BED file must be sorted by chrom, then start"
        max_distance:
          type: int?
          inputBinding:
            position: 6
            prefix: "-d"
          doc: "Maximum distance between features to be merged" 
        output_filename:
          type: string?
          default: ""
          doc: "Output file name"
      outputs:
        merged_bed_file:
          type: File
          outputBinding:
            glob: $(default_output_filename())
          doc: "Merged BED file"
      baseCommand: ["bedtools", "merge"]
      stdout: $(default_output_filename())
    in:
      bed_file: sort_peaks/sorted_file
    out: [merged_bed_file]

  count_tags:
    run:
      cwlVersion: v1.0
      class: CommandLineTool
      requirements:
      - class: InlineJavascriptRequirement
        expressionLib:
        - var default_output_filename = function() {
                if (inputs.output_filename == ""){
                  return inputs.file_a.basename;
                } else {
                  return inputs.output_filename;
                }
              };
      hints:
      - class: DockerRequirement
        dockerPull: biowardrobe2/bedtools2:v2.26.0
      inputs:
        file_a:
          type: File
          inputBinding:
            position: 5
            prefix: "-a"
          doc: "BAM/BED/GFF/VCF file A. Each feature in A is compared to B in search of overlaps"
        file_b:
          type: File
          inputBinding:
            position: 6
            prefix: "-b"
          doc: "BAM/BED/GFF/VCF file B. Each feature in A is compared to B in search of overlaps"
        count:
          type: boolean?
          inputBinding:
            position: 7
            prefix: "-c"
          doc: "For each entry in A, report the number of hits in B. Reports 0 for A entries that have no overlap with B" 
        no_overlaps:
          type: boolean?
          inputBinding:
            position: 8
            prefix: "-v"
          doc: "Only report those entries in A that have _no overlaps_ with B" 
        output_filename:
          type: string?
          default: ""
          doc: "Output file name"
      outputs:
        intersected_file:
          type: File
          outputBinding:
            glob: $(default_output_filename())
          doc: "Intersected BED file"
      baseCommand: ["bedtools", "intersect"]
      stdout: $(default_output_filename())
    in:
      file_a: merge_peaks/merged_bed_file
      file_b: remove_blacklisted/intersected_file
      count:
        default: true
    out: [intersected_file]

  get_sequences:
    run:
      cwlVersion: v1.0
      class: CommandLineTool
      requirements:
      - class: InlineJavascriptRequirement
        expressionLib:
        - var default_output_filename = function() {
                if (inputs.output_filename == ""){
                  var root = inputs.intervals_file.basename.split('.').slice(0,-1).join('.');
                  return (root == "")?inputs.intervals_file.basename+".fa":root+".fa";
                } else {
                  return inputs.output_filename;
                }
              };
      hints:
      - class: DockerRequirement
        dockerPull: biowardrobe2/bedtools2:v2.26.0
      inputs:
        genome_fasta_file:
          type: File
          secondaryFiles: $(self.basename+".fai")  # due to bug in cwltool==1.0.20190621234233
          inputBinding:
            position: 5
            prefix: "-fi"
          doc: "Genome file in FASTA format"
        intervals_file:
          type: File
          inputBinding:
            position: 6
            prefix: "-bed"
          doc: "Intervals file defined in a BED/GFF/VCF format"
        output_filename:
          type: string?
          default: ""
          doc: "Output file name"
      outputs:
        sequences_file:
          type: File
          outputBinding:
            glob: $(default_output_filename())
          doc: "Sequences file"
      baseCommand: ["bedtools", "getfasta"]
      stdout: $(default_output_filename())
    in:
      genome_fasta_file: genome_fasta_file
      intervals_file: merge_peaks/merged_bed_file
    out: [sequences_file]